
import token
from typing import Any, Dict, Optional, IO, Text, Tuple
from pegen.grammar import Cut, GrammarVisitor, NameLeaf, StringLeaf, Rhs, NamedItem, Lookahead, PositiveLookahead, NegativeLookahead, Opt, Repeat0, Repeat1, Gather, Group, Rule, Alt
from pegen import grammar
from pegen.parser_generator import ParserGenerator
MODULE_PREFIX = '#!/usr/bin/env python3.8\n# @generated by pegen from {filename}\n\nimport ast\nimport sys\nimport tokenize\n\nfrom typing import Any, Optional\n\nfrom pegen.parser import memoize, memoize_left_rec, logger, Parser\n\n'
MODULE_SUFFIX = "\n\nif __name__ == '__main__':\n    from pegen.parser import simple_parser_main\n    simple_parser_main(GeneratedParser)\n"

class PythonCallMakerVisitor(GrammarVisitor):

    def __init__(self, parser_generator):
        self.gen = parser_generator
        self.cache: Dict[(Any, Any)] = {}

    def visit_NameLeaf(self, node):
        name = node.value
        if (name in ('NAME', 'NUMBER', 'STRING', 'OP')):
            name = name.lower()
            return (name, f'self.{name}()')
        if (name in ('NEWLINE', 'DEDENT', 'INDENT', 'ENDMARKER', 'ASYNC', 'AWAIT')):
            return (name.lower(), f'self.expect({name!r})')
        return (name, f'self.{name}()')

    def visit_StringLeaf(self, node):
        return ('literal', f'self.expect({node.value})')

    def visit_Rhs(self, node):
        if (node in self.cache):
            return self.cache[node]
        if ((len(node.alts) == 1) and (len(node.alts[0].items) == 1)):
            self.cache[node] = self.visit(node.alts[0].items[0])
        else:
            name = self.gen.name_node(node)
            self.cache[node] = (name, f'self.{name}()')
        return self.cache[node]

    def visit_NamedItem(self, node):
        (name, call) = self.visit(node.item)
        if node.name:
            name = node.name
        return (name, call)

    def lookahead_call_helper(self, node):
        (name, call) = self.visit(node.node)
        (head, tail) = call.split('(', 1)
        assert (tail[(- 1)] == ')')
        tail = tail[:(- 1)]
        return (head, tail)

    def visit_PositiveLookahead(self, node):
        (head, tail) = self.lookahead_call_helper(node)
        return (None, f'self.positive_lookahead({head}, {tail})')

    def visit_NegativeLookahead(self, node):
        (head, tail) = self.lookahead_call_helper(node)
        return (None, f'self.negative_lookahead({head}, {tail})')

    def visit_Opt(self, node):
        (name, call) = self.visit(node.node)
        if call.endswith(','):
            return ('opt', call)
        else:
            return ('opt', f'{call},')

    def visit_Repeat0(self, node):
        if (node in self.cache):
            return self.cache[node]
        name = self.gen.name_loop(node.node, False)
        self.cache[node] = (name, f'self.{name}(),')
        return self.cache[node]

    def visit_Repeat1(self, node):
        if (node in self.cache):
            return self.cache[node]
        name = self.gen.name_loop(node.node, True)
        self.cache[node] = (name, f'self.{name}()')
        return self.cache[node]

    def visit_Gather(self, node):
        if (node in self.cache):
            return self.cache[node]
        name = self.gen.name_gather(node)
        self.cache[node] = (name, f'self.{name}()')
        return self.cache[node]

    def visit_Group(self, node):
        return self.visit(node.rhs)

    def visit_Cut(self, node):
        return ('cut', 'True')

class PythonParserGenerator(ParserGenerator, GrammarVisitor):

    def __init__(self, grammar, file, tokens=token.tok_name):
        super().__init__(grammar, tokens, file)
        self.callmakervisitor = PythonCallMakerVisitor(self)

    def generate(self, filename):
        header = self.grammar.metas.get('header', MODULE_PREFIX)
        if (header is not None):
            self.print(header.rstrip('\n').format(filename=filename))
        subheader = self.grammar.metas.get('subheader', '')
        if subheader:
            self.print(subheader.format(filename=filename))
        self.print('class GeneratedParser(Parser):')
        while self.todo:
            for (rulename, rule) in list(self.todo.items()):
                del self.todo[rulename]
                self.print()
                with self.indent():
                    self.visit(rule)
        trailer = self.grammar.metas.get('trailer', MODULE_SUFFIX)
        if (trailer is not None):
            self.print(trailer.rstrip('\n'))

    def visit_Rule(self, node):
        is_loop = node.is_loop()
        is_gather = node.is_gather()
        rhs = node.flatten()
        if node.left_recursive:
            if node.leader:
                self.print('@memoize_left_rec')
            else:
                self.print('@logger')
        else:
            self.print('@memoize')
        node_type = (node.type or 'Any')
        self.print(f'def {node.name}(self) -> Optional[{node_type}]:')
        with self.indent():
            self.print(f'# {node.name}: {rhs}')
            if node.nullable:
                self.print(f'# nullable={node.nullable}')
            self.print('mark = self.mark()')
            if is_loop:
                self.print('children = []')
            self.visit(rhs, is_loop=is_loop, is_gather=is_gather)
            if is_loop:
                self.print('return children')
            else:
                self.print('return None')

    def visit_NamedItem(self, node):
        (name, call) = self.callmakervisitor.visit(node.item)
        if node.name:
            name = node.name
        if (not name):
            self.print(call)
        else:
            if (name != 'cut'):
                name = self.dedupe(name)
            self.print(f'({name} := {call})')

    def visit_Rhs(self, node, is_loop=False, is_gather=False):
        if is_loop:
            assert (len(node.alts) == 1)
        for alt in node.alts:
            self.visit(alt, is_loop=is_loop, is_gather=is_gather)

    def visit_Alt(self, node, is_loop, is_gather):
        with self.local_variable_context():
            self.print('cut = False')
            if is_loop:
                self.print('while (')
            else:
                self.print('if (')
            with self.indent():
                first = True
                for item in node.items:
                    if first:
                        first = False
                    else:
                        self.print('and')
                    self.visit(item)
            self.print('):')
            with self.indent():
                action = node.action
                if (not action):
                    if is_gather:
                        assert (len(self.local_variable_names) == 2)
                        action = f'[{self.local_variable_names[0]}] + {self.local_variable_names[1]}'
                    else:
                        action = f"[{', '.join(self.local_variable_names)}]"
                if is_loop:
                    self.print(f'children.append({action})')
                    self.print(f'mark = self.mark()')
                else:
                    self.print(f'return {action}')
            self.print('self.reset(mark)')
            self.print('if cut: return None')
