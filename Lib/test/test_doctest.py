
'\nTest script for doctest.\n'
from test import support
from test.support import import_helper
from test.support import os_helper
import doctest
import functools
import os
import sys
import importlib
import importlib.abc
import importlib.util
import unittest
import tempfile
import shutil
import contextlib

def sample_func(v):
    '\n    Blah blah\n\n    >>> print(sample_func(22))\n    44\n\n    Yee ha!\n    '
    return (v + v)

class SampleClass():
    "\n    >>> print(1)\n    1\n\n    >>> # comments get ignored.  so are empty PS1 and PS2 prompts:\n    >>>\n    ...\n\n    Multiline example:\n    >>> sc = SampleClass(3)\n    >>> for i in range(10):\n    ...     sc = sc.double()\n    ...     print(' ', sc.get(), sep='', end='')\n     6 12 24 48 96 192 384 768 1536 3072\n    "

    def __init__(self, val):
        '\n        >>> print(SampleClass(12).get())\n        12\n        '
        self.val = val

    def double(self):
        '\n        >>> print(SampleClass(12).double().get())\n        24\n        '
        return SampleClass((self.val + self.val))

    def get(self):
        '\n        >>> print(SampleClass(-5).get())\n        -5\n        '
        return self.val

    def a_staticmethod(v):
        '\n        >>> print(SampleClass.a_staticmethod(10))\n        11\n        '
        return (v + 1)
    a_staticmethod = staticmethod(a_staticmethod)

    def a_classmethod(cls, v):
        '\n        >>> print(SampleClass.a_classmethod(10))\n        12\n        >>> print(SampleClass(0).a_classmethod(10))\n        12\n        '
        return (v + 2)
    a_classmethod = classmethod(a_classmethod)
    a_property = property(get, doc='\n        >>> print(SampleClass(22).a_property)\n        22\n        ')

    class NestedClass():
        '\n        >>> x = SampleClass.NestedClass(5)\n        >>> y = x.square()\n        >>> print(y.get())\n        25\n        '

        def __init__(self, val=0):
            '\n            >>> print(SampleClass.NestedClass().get())\n            0\n            '
            self.val = val

        def square(self):
            return SampleClass.NestedClass((self.val * self.val))

        def get(self):
            return self.val

class SampleNewStyleClass(object):
    "\n    >>> print('1\\n2\\n3')\n    1\n    2\n    3\n    "

    def __init__(self, val):
        '\n        >>> print(SampleNewStyleClass(12).get())\n        12\n        '
        self.val = val

    def double(self):
        '\n        >>> print(SampleNewStyleClass(12).double().get())\n        24\n        '
        return SampleNewStyleClass((self.val + self.val))

    def get(self):
        '\n        >>> print(SampleNewStyleClass(-5).get())\n        -5\n        '
        return self.val

class _FakeInput():
    "\n    A fake input stream for pdb's interactive debugger.  Whenever a\n    line is read, print it (to simulate the user typing it), and then\n    return it.  The set of lines to return is specified in the\n    constructor; they should not have trailing newlines.\n    "

    def __init__(self, lines):
        self.lines = lines

    def readline(self):
        line = self.lines.pop(0)
        print(line)
        return (line + '\n')

def test_Example():
    '\nUnit tests for the `Example` class.\n\nExample is a simple container class that holds:\n  - `source`: A source string.\n  - `want`: An expected output string.\n  - `exc_msg`: An expected exception message string (or None if no\n    exception is expected).\n  - `lineno`: A line number (within the docstring).\n  - `indent`: The example\'s indentation in the input string.\n  - `options`: An option dictionary, mapping option flags to True or\n    False.\n\nThese attributes are set by the constructor.  `source` and `want` are\nrequired; the other attributes all have default values:\n\n    >>> example = doctest.Example(\'print(1)\', \'1\\n\')\n    >>> (example.source, example.want, example.exc_msg,\n    ...  example.lineno, example.indent, example.options)\n    (\'print(1)\\n\', \'1\\n\', None, 0, 0, {})\n\nThe first three attributes (`source`, `want`, and `exc_msg`) may be\nspecified positionally; the remaining arguments should be specified as\nkeyword arguments:\n\n    >>> exc_msg = \'IndexError: pop from an empty list\'\n    >>> example = doctest.Example(\'[].pop()\', \'\', exc_msg,\n    ...                           lineno=5, indent=4,\n    ...                           options={doctest.ELLIPSIS: True})\n    >>> (example.source, example.want, example.exc_msg,\n    ...  example.lineno, example.indent, example.options)\n    (\'[].pop()\\n\', \'\', \'IndexError: pop from an empty list\\n\', 5, 4, {8: True})\n\nThe constructor normalizes the `source` string to end in a newline:\n\n    Source spans a single line: no terminating newline.\n    >>> e = doctest.Example(\'print(1)\', \'1\\n\')\n    >>> e.source, e.want\n    (\'print(1)\\n\', \'1\\n\')\n\n    >>> e = doctest.Example(\'print(1)\\n\', \'1\\n\')\n    >>> e.source, e.want\n    (\'print(1)\\n\', \'1\\n\')\n\n    Source spans multiple lines: require terminating newline.\n    >>> e = doctest.Example(\'print(1);\\nprint(2)\\n\', \'1\\n2\\n\')\n    >>> e.source, e.want\n    (\'print(1);\\nprint(2)\\n\', \'1\\n2\\n\')\n\n    >>> e = doctest.Example(\'print(1);\\nprint(2)\', \'1\\n2\\n\')\n    >>> e.source, e.want\n    (\'print(1);\\nprint(2)\\n\', \'1\\n2\\n\')\n\n    Empty source string (which should never appear in real examples)\n    >>> e = doctest.Example(\'\', \'\')\n    >>> e.source, e.want\n    (\'\\n\', \'\')\n\nThe constructor normalizes the `want` string to end in a newline,\nunless it\'s the empty string:\n\n    >>> e = doctest.Example(\'print(1)\', \'1\\n\')\n    >>> e.source, e.want\n    (\'print(1)\\n\', \'1\\n\')\n\n    >>> e = doctest.Example(\'print(1)\', \'1\')\n    >>> e.source, e.want\n    (\'print(1)\\n\', \'1\\n\')\n\n    >>> e = doctest.Example(\'print\', \'\')\n    >>> e.source, e.want\n    (\'print\\n\', \'\')\n\nThe constructor normalizes the `exc_msg` string to end in a newline,\nunless it\'s `None`:\n\n    Message spans one line\n    >>> exc_msg = \'IndexError: pop from an empty list\'\n    >>> e = doctest.Example(\'[].pop()\', \'\', exc_msg)\n    >>> e.exc_msg\n    \'IndexError: pop from an empty list\\n\'\n\n    >>> exc_msg = \'IndexError: pop from an empty list\\n\'\n    >>> e = doctest.Example(\'[].pop()\', \'\', exc_msg)\n    >>> e.exc_msg\n    \'IndexError: pop from an empty list\\n\'\n\n    Message spans multiple lines\n    >>> exc_msg = \'ValueError: 1\\n  2\'\n    >>> e = doctest.Example(\'raise ValueError("1\\n  2")\', \'\', exc_msg)\n    >>> e.exc_msg\n    \'ValueError: 1\\n  2\\n\'\n\n    >>> exc_msg = \'ValueError: 1\\n  2\\n\'\n    >>> e = doctest.Example(\'raise ValueError("1\\n  2")\', \'\', exc_msg)\n    >>> e.exc_msg\n    \'ValueError: 1\\n  2\\n\'\n\n    Empty (but non-None) exception message (which should never appear\n    in real examples)\n    >>> exc_msg = \'\'\n    >>> e = doctest.Example(\'raise X()\', \'\', exc_msg)\n    >>> e.exc_msg\n    \'\\n\'\n\nCompare `Example`:\n    >>> example = doctest.Example(\'print 1\', \'1\\n\')\n    >>> same_example = doctest.Example(\'print 1\', \'1\\n\')\n    >>> other_example = doctest.Example(\'print 42\', \'42\\n\')\n    >>> example == same_example\n    True\n    >>> example != same_example\n    False\n    >>> hash(example) == hash(same_example)\n    True\n    >>> example == other_example\n    False\n    >>> example != other_example\n    True\n'

def test_DocTest():
    '\nUnit tests for the `DocTest` class.\n\nDocTest is a collection of examples, extracted from a docstring, along\nwith information about where the docstring comes from (a name,\nfilename, and line number).  The docstring is parsed by the `DocTest`\nconstructor:\n\n    >>> docstring = \'\'\'\n    ...     >>> print(12)\n    ...     12\n    ...\n    ... Non-example text.\n    ...\n    ...     >>> print(\'another\\\\example\')\n    ...     another\n    ...     example\n    ... \'\'\'\n    >>> globs = {} # globals to run the test in.\n    >>> parser = doctest.DocTestParser()\n    >>> test = parser.get_doctest(docstring, globs, \'some_test\',\n    ...                           \'some_file\', 20)\n    >>> print(test)\n    <DocTest some_test from some_file:20 (2 examples)>\n    >>> len(test.examples)\n    2\n    >>> e1, e2 = test.examples\n    >>> (e1.source, e1.want, e1.lineno)\n    (\'print(12)\\n\', \'12\\n\', 1)\n    >>> (e2.source, e2.want, e2.lineno)\n    ("print(\'another\\\\example\')\\n", \'another\\nexample\\n\', 6)\n\nSource information (name, filename, and line number) is available as\nattributes on the doctest object:\n\n    >>> (test.name, test.filename, test.lineno)\n    (\'some_test\', \'some_file\', 20)\n\nThe line number of an example within its containing file is found by\nadding the line number of the example and the line number of its\ncontaining test:\n\n    >>> test.lineno + e1.lineno\n    21\n    >>> test.lineno + e2.lineno\n    26\n\nIf the docstring contains inconsistent leading whitespace in the\nexpected output of an example, then `DocTest` will raise a ValueError:\n\n    >>> docstring = r\'\'\'\n    ...       >>> print(\'bad\\nindentation\')\n    ...       bad\n    ...     indentation\n    ...     \'\'\'\n    >>> parser.get_doctest(docstring, globs, \'some_test\', \'filename\', 0)\n    Traceback (most recent call last):\n    ValueError: line 4 of the docstring for some_test has inconsistent leading whitespace: \'indentation\'\n\nIf the docstring contains inconsistent leading whitespace on\ncontinuation lines, then `DocTest` will raise a ValueError:\n\n    >>> docstring = r\'\'\'\n    ...       >>> print((\'bad indentation\',\n    ...     ...          2))\n    ...       (\'bad\', \'indentation\')\n    ...     \'\'\'\n    >>> parser.get_doctest(docstring, globs, \'some_test\', \'filename\', 0)\n    Traceback (most recent call last):\n    ValueError: line 2 of the docstring for some_test has inconsistent leading whitespace: \'...          2))\'\n\nIf there\'s no blank space after a PS1 prompt (\'>>>\'), then `DocTest`\nwill raise a ValueError:\n\n    >>> docstring = \'>>>print(1)\\n1\'\n    >>> parser.get_doctest(docstring, globs, \'some_test\', \'filename\', 0)\n    Traceback (most recent call last):\n    ValueError: line 1 of the docstring for some_test lacks blank after >>>: \'>>>print(1)\'\n\nIf there\'s no blank space after a PS2 prompt (\'...\'), then `DocTest`\nwill raise a ValueError:\n\n    >>> docstring = \'>>> if 1:\\n...print(1)\\n1\'\n    >>> parser.get_doctest(docstring, globs, \'some_test\', \'filename\', 0)\n    Traceback (most recent call last):\n    ValueError: line 2 of the docstring for some_test lacks blank after ...: \'...print(1)\'\n\nCompare `DocTest`:\n\n    >>> docstring = \'\'\'\n    ...     >>> print 12\n    ...     12\n    ... \'\'\'\n    >>> test = parser.get_doctest(docstring, globs, \'some_test\',\n    ...                           \'some_test\', 20)\n    >>> same_test = parser.get_doctest(docstring, globs, \'some_test\',\n    ...                                \'some_test\', 20)\n    >>> test == same_test\n    True\n    >>> test != same_test\n    False\n    >>> hash(test) == hash(same_test)\n    True\n    >>> docstring = \'\'\'\n    ...     >>> print 42\n    ...     42\n    ... \'\'\'\n    >>> other_test = parser.get_doctest(docstring, globs, \'other_test\',\n    ...                                 \'other_file\', 10)\n    >>> test == other_test\n    False\n    >>> test != other_test\n    True\n\nCompare `DocTestCase`:\n\n    >>> DocTestCase = doctest.DocTestCase\n    >>> test_case = DocTestCase(test)\n    >>> same_test_case = DocTestCase(same_test)\n    >>> other_test_case = DocTestCase(other_test)\n    >>> test_case == same_test_case\n    True\n    >>> test_case != same_test_case\n    False\n    >>> hash(test_case) == hash(same_test_case)\n    True\n    >>> test == other_test_case\n    False\n    >>> test != other_test_case\n    True\n\n'

class test_DocTestFinder():

    def basics():
        "\nUnit tests for the `DocTestFinder` class.\n\nDocTestFinder is used to extract DocTests from an object's docstring\nand the docstrings of its contained objects.  It can be used with\nmodules, functions, classes, methods, staticmethods, classmethods, and\nproperties.\n\nFinding Tests in Functions\n~~~~~~~~~~~~~~~~~~~~~~~~~~\nFor a function whose docstring contains examples, DocTestFinder.find()\nwill return a single test (for that function's docstring):\n\n    >>> finder = doctest.DocTestFinder()\n\nWe'll simulate a __file__ attr that ends in pyc:\n\n    >>> import test.test_doctest\n    >>> old = test.test_doctest.__file__\n    >>> test.test_doctest.__file__ = 'test_doctest.pyc'\n\n    >>> tests = finder.find(sample_func)\n\n    >>> print(tests)  # doctest: +ELLIPSIS\n    [<DocTest sample_func from ...:27 (1 example)>]\n\nThe exact name depends on how test_doctest was invoked, so allow for\nleading path components.\n\n    >>> tests[0].filename # doctest: +ELLIPSIS\n    '...test_doctest.py'\n\n    >>> test.test_doctest.__file__ = old\n\n\n    >>> e = tests[0].examples[0]\n    >>> (e.source, e.want, e.lineno)\n    ('print(sample_func(22))\\n', '44\\n', 3)\n\nBy default, tests are created for objects with no docstring:\n\n    >>> def no_docstring(v):\n    ...     pass\n    >>> finder.find(no_docstring)\n    []\n\nHowever, the optional argument `exclude_empty` to the DocTestFinder\nconstructor can be used to exclude tests for objects with empty\ndocstrings:\n\n    >>> def no_docstring(v):\n    ...     pass\n    >>> excl_empty_finder = doctest.DocTestFinder(exclude_empty=True)\n    >>> excl_empty_finder.find(no_docstring)\n    []\n\nIf the function has a docstring with no examples, then a test with no\nexamples is returned.  (This lets `DocTestRunner` collect statistics\nabout which functions have no tests -- but is that useful?  And should\nan empty test also be created when there's no docstring?)\n\n    >>> def no_examples(v):\n    ...     ''' no doctest examples '''\n    >>> finder.find(no_examples) # doctest: +ELLIPSIS\n    [<DocTest no_examples from ...:1 (no examples)>]\n\nFinding Tests in Classes\n~~~~~~~~~~~~~~~~~~~~~~~~\nFor a class, DocTestFinder will create a test for the class's\ndocstring, and will recursively explore its contents, including\nmethods, classmethods, staticmethods, properties, and nested classes.\n\n    >>> finder = doctest.DocTestFinder()\n    >>> tests = finder.find(SampleClass)\n    >>> for t in tests:\n    ...     print('%2s  %s' % (len(t.examples), t.name))\n     3  SampleClass\n     3  SampleClass.NestedClass\n     1  SampleClass.NestedClass.__init__\n     1  SampleClass.__init__\n     2  SampleClass.a_classmethod\n     1  SampleClass.a_property\n     1  SampleClass.a_staticmethod\n     1  SampleClass.double\n     1  SampleClass.get\n\nNew-style classes are also supported:\n\n    >>> tests = finder.find(SampleNewStyleClass)\n    >>> for t in tests:\n    ...     print('%2s  %s' % (len(t.examples), t.name))\n     1  SampleNewStyleClass\n     1  SampleNewStyleClass.__init__\n     1  SampleNewStyleClass.double\n     1  SampleNewStyleClass.get\n\nFinding Tests in Modules\n~~~~~~~~~~~~~~~~~~~~~~~~\nFor a module, DocTestFinder will create a test for the class's\ndocstring, and will recursively explore its contents, including\nfunctions, classes, and the `__test__` dictionary, if it exists:\n\n    >>> # A module\n    >>> import types\n    >>> m = types.ModuleType('some_module')\n    >>> def triple(val):\n    ...     '''\n    ...     >>> print(triple(11))\n    ...     33\n    ...     '''\n    ...     return val*3\n    >>> m.__dict__.update({\n    ...     'sample_func': sample_func,\n    ...     'SampleClass': SampleClass,\n    ...     '__doc__': '''\n    ...         Module docstring.\n    ...             >>> print('module')\n    ...             module\n    ...         ''',\n    ...     '__test__': {\n    ...         'd': '>>> print(6)\\n6\\n>>> print(7)\\n7\\n',\n    ...         'c': triple}})\n\n    >>> finder = doctest.DocTestFinder()\n    >>> # Use module=test.test_doctest, to prevent doctest from\n    >>> # ignoring the objects since they weren't defined in m.\n    >>> import test.test_doctest\n    >>> tests = finder.find(m, module=test.test_doctest)\n    >>> for t in tests:\n    ...     print('%2s  %s' % (len(t.examples), t.name))\n     1  some_module\n     3  some_module.SampleClass\n     3  some_module.SampleClass.NestedClass\n     1  some_module.SampleClass.NestedClass.__init__\n     1  some_module.SampleClass.__init__\n     2  some_module.SampleClass.a_classmethod\n     1  some_module.SampleClass.a_property\n     1  some_module.SampleClass.a_staticmethod\n     1  some_module.SampleClass.double\n     1  some_module.SampleClass.get\n     1  some_module.__test__.c\n     2  some_module.__test__.d\n     1  some_module.sample_func\n\nDuplicate Removal\n~~~~~~~~~~~~~~~~~\nIf a single object is listed twice (under different names), then tests\nwill only be generated for it once:\n\n    >>> from test import doctest_aliases\n    >>> assert doctest_aliases.TwoNames.f\n    >>> assert doctest_aliases.TwoNames.g\n    >>> tests = excl_empty_finder.find(doctest_aliases)\n    >>> print(len(tests))\n    2\n    >>> print(tests[0].name)\n    test.doctest_aliases.TwoNames\n\n    TwoNames.f and TwoNames.g are bound to the same object.\n    We can't guess which will be found in doctest's traversal of\n    TwoNames.__dict__ first, so we have to allow for either.\n\n    >>> tests[1].name.split('.')[-1] in ['f', 'g']\n    True\n\nEmpty Tests\n~~~~~~~~~~~\nBy default, an object with no doctests doesn't create any tests:\n\n    >>> tests = doctest.DocTestFinder().find(SampleClass)\n    >>> for t in tests:\n    ...     print('%2s  %s' % (len(t.examples), t.name))\n     3  SampleClass\n     3  SampleClass.NestedClass\n     1  SampleClass.NestedClass.__init__\n     1  SampleClass.__init__\n     2  SampleClass.a_classmethod\n     1  SampleClass.a_property\n     1  SampleClass.a_staticmethod\n     1  SampleClass.double\n     1  SampleClass.get\n\nBy default, that excluded objects with no doctests.  exclude_empty=False\ntells it to include (empty) tests for objects with no doctests.  This feature\nis really to support backward compatibility in what doctest.master.summarize()\ndisplays.\n\n    >>> tests = doctest.DocTestFinder(exclude_empty=False).find(SampleClass)\n    >>> for t in tests:\n    ...     print('%2s  %s' % (len(t.examples), t.name))\n     3  SampleClass\n     3  SampleClass.NestedClass\n     1  SampleClass.NestedClass.__init__\n     0  SampleClass.NestedClass.get\n     0  SampleClass.NestedClass.square\n     1  SampleClass.__init__\n     2  SampleClass.a_classmethod\n     1  SampleClass.a_property\n     1  SampleClass.a_staticmethod\n     1  SampleClass.double\n     1  SampleClass.get\n\nTurning off Recursion\n~~~~~~~~~~~~~~~~~~~~~\nDocTestFinder can be told not to look for tests in contained objects\nusing the `recurse` flag:\n\n    >>> tests = doctest.DocTestFinder(recurse=False).find(SampleClass)\n    >>> for t in tests:\n    ...     print('%2s  %s' % (len(t.examples), t.name))\n     3  SampleClass\n\nLine numbers\n~~~~~~~~~~~~\nDocTestFinder finds the line number of each example:\n\n    >>> def f(x):\n    ...     '''\n    ...     >>> x = 12\n    ...\n    ...     some text\n    ...\n    ...     >>> # examples are not created for comments & bare prompts.\n    ...     >>>\n    ...     ...\n    ...\n    ...     >>> for x in range(10):\n    ...     ...     print(x, end=' ')\n    ...     0 1 2 3 4 5 6 7 8 9\n    ...     >>> x//2\n    ...     6\n    ...     '''\n    >>> test = doctest.DocTestFinder().find(f)[0]\n    >>> [e.lineno for e in test.examples]\n    [1, 9, 12]\n"
    if int.__doc__:

        def non_Python_modules():
            "\n\nFinding Doctests in Modules Not Written in Python\n~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nDocTestFinder can also find doctests in most modules not written in Python.\nWe'll use builtins as an example, since it almost certainly isn't written in\nplain ol' Python and is guaranteed to be available.\n\n    >>> import builtins\n    >>> tests = doctest.DocTestFinder().find(builtins)\n    >>> 816 < len(tests) < 836 # approximate number of objects with docstrings\n    True\n    >>> real_tests = [t for t in tests if len(t.examples) > 0]\n    >>> len(real_tests) # objects that actually have doctests\n    14\n    >>> for t in real_tests:\n    ...     print('{}  {}'.format(len(t.examples), t.name))\n    ...\n    1  builtins.bin\n    5  builtins.bytearray.hex\n    5  builtins.bytes.hex\n    3  builtins.float.as_integer_ratio\n    2  builtins.float.fromhex\n    2  builtins.float.hex\n    1  builtins.hex\n    1  builtins.int\n    3  builtins.int.as_integer_ratio\n    2  builtins.int.bit_count\n    2  builtins.int.bit_length\n    5  builtins.memoryview.hex\n    1  builtins.oct\n    1  builtins.zip\n\nNote here that 'bin', 'oct', and 'hex' are functions; 'float.as_integer_ratio',\n'float.hex', and 'int.bit_length' are methods; 'float.fromhex' is a classmethod,\nand 'int' is a type.\n"

class TestDocTestFinder(unittest.TestCase):

    def test_empty_namespace_package(self):
        pkg_name = 'doctest_empty_pkg'
        with tempfile.TemporaryDirectory() as parent_dir:
            pkg_dir = os.path.join(parent_dir, pkg_name)
            os.mkdir(pkg_dir)
            sys.path.append(parent_dir)
            try:
                mod = importlib.import_module(pkg_name)
            finally:
                import_helper.forget(pkg_name)
                sys.path.pop()
            include_empty_finder = doctest.DocTestFinder(exclude_empty=False)
            exclude_empty_finder = doctest.DocTestFinder(exclude_empty=True)
            self.assertEqual(len(include_empty_finder.find(mod)), 1)
            self.assertEqual(len(exclude_empty_finder.find(mod)), 0)

def test_DocTestParser():
    "\nUnit tests for the `DocTestParser` class.\n\nDocTestParser is used to parse docstrings containing doctest examples.\n\nThe `parse` method divides a docstring into examples and intervening\ntext:\n\n    >>> s = '''\n    ...     >>> x, y = 2, 3  # no output expected\n    ...     >>> if 1:\n    ...     ...     print(x)\n    ...     ...     print(y)\n    ...     2\n    ...     3\n    ...\n    ...     Some text.\n    ...     >>> x+y\n    ...     5\n    ...     '''\n    >>> parser = doctest.DocTestParser()\n    >>> for piece in parser.parse(s):\n    ...     if isinstance(piece, doctest.Example):\n    ...         print('Example:', (piece.source, piece.want, piece.lineno))\n    ...     else:\n    ...         print('   Text:', repr(piece))\n       Text: '\\n'\n    Example: ('x, y = 2, 3  # no output expected\\n', '', 1)\n       Text: ''\n    Example: ('if 1:\\n    print(x)\\n    print(y)\\n', '2\\n3\\n', 2)\n       Text: '\\nSome text.\\n'\n    Example: ('x+y\\n', '5\\n', 9)\n       Text: ''\n\nThe `get_examples` method returns just the examples:\n\n    >>> for piece in parser.get_examples(s):\n    ...     print((piece.source, piece.want, piece.lineno))\n    ('x, y = 2, 3  # no output expected\\n', '', 1)\n    ('if 1:\\n    print(x)\\n    print(y)\\n', '2\\n3\\n', 2)\n    ('x+y\\n', '5\\n', 9)\n\nThe `get_doctest` method creates a Test from the examples, along with the\ngiven arguments:\n\n    >>> test = parser.get_doctest(s, {}, 'name', 'filename', lineno=5)\n    >>> (test.name, test.filename, test.lineno)\n    ('name', 'filename', 5)\n    >>> for piece in test.examples:\n    ...     print((piece.source, piece.want, piece.lineno))\n    ('x, y = 2, 3  # no output expected\\n', '', 1)\n    ('if 1:\\n    print(x)\\n    print(y)\\n', '2\\n3\\n', 2)\n    ('x+y\\n', '5\\n', 9)\n"

class test_DocTestRunner():

    def basics():
        "\nUnit tests for the `DocTestRunner` class.\n\nDocTestRunner is used to run DocTest test cases, and to accumulate\nstatistics.  Here's a simple DocTest case we can use:\n\n    >>> def f(x):\n    ...     '''\n    ...     >>> x = 12\n    ...     >>> print(x)\n    ...     12\n    ...     >>> x//2\n    ...     6\n    ...     '''\n    >>> test = doctest.DocTestFinder().find(f)[0]\n\nThe main DocTestRunner interface is the `run` method, which runs a\ngiven DocTest case in a given namespace (globs).  It returns a tuple\n`(f,t)`, where `f` is the number of failed tests and `t` is the number\nof tried tests.\n\n    >>> doctest.DocTestRunner(verbose=False).run(test)\n    TestResults(failed=0, attempted=3)\n\nIf any example produces incorrect output, then the test runner reports\nthe failure and proceeds to the next example:\n\n    >>> def f(x):\n    ...     '''\n    ...     >>> x = 12\n    ...     >>> print(x)\n    ...     14\n    ...     >>> x//2\n    ...     6\n    ...     '''\n    >>> test = doctest.DocTestFinder().find(f)[0]\n    >>> doctest.DocTestRunner(verbose=True).run(test)\n    ... # doctest: +ELLIPSIS\n    Trying:\n        x = 12\n    Expecting nothing\n    ok\n    Trying:\n        print(x)\n    Expecting:\n        14\n    **********************************************************************\n    File ..., line 4, in f\n    Failed example:\n        print(x)\n    Expected:\n        14\n    Got:\n        12\n    Trying:\n        x//2\n    Expecting:\n        6\n    ok\n    TestResults(failed=1, attempted=3)\n"

    def verbose_flag():
        "\nThe `verbose` flag makes the test runner generate more detailed\noutput:\n\n    >>> def f(x):\n    ...     '''\n    ...     >>> x = 12\n    ...     >>> print(x)\n    ...     12\n    ...     >>> x//2\n    ...     6\n    ...     '''\n    >>> test = doctest.DocTestFinder().find(f)[0]\n\n    >>> doctest.DocTestRunner(verbose=True).run(test)\n    Trying:\n        x = 12\n    Expecting nothing\n    ok\n    Trying:\n        print(x)\n    Expecting:\n        12\n    ok\n    Trying:\n        x//2\n    Expecting:\n        6\n    ok\n    TestResults(failed=0, attempted=3)\n\nIf the `verbose` flag is unspecified, then the output will be verbose\niff `-v` appears in sys.argv:\n\n    >>> # Save the real sys.argv list.\n    >>> old_argv = sys.argv\n\n    >>> # If -v does not appear in sys.argv, then output isn't verbose.\n    >>> sys.argv = ['test']\n    >>> doctest.DocTestRunner().run(test)\n    TestResults(failed=0, attempted=3)\n\n    >>> # If -v does appear in sys.argv, then output is verbose.\n    >>> sys.argv = ['test', '-v']\n    >>> doctest.DocTestRunner().run(test)\n    Trying:\n        x = 12\n    Expecting nothing\n    ok\n    Trying:\n        print(x)\n    Expecting:\n        12\n    ok\n    Trying:\n        x//2\n    Expecting:\n        6\n    ok\n    TestResults(failed=0, attempted=3)\n\n    >>> # Restore sys.argv\n    >>> sys.argv = old_argv\n\nIn the remaining examples, the test runner's verbosity will be\nexplicitly set, to ensure that the test behavior is consistent.\n    "

    def exceptions():
        "\nTests of `DocTestRunner`'s exception handling.\n\nAn expected exception is specified with a traceback message.  The\nlines between the first line and the type/value may be omitted or\nreplaced with any other string:\n\n    >>> def f(x):\n    ...     '''\n    ...     >>> x = 12\n    ...     >>> print(x//0)\n    ...     Traceback (most recent call last):\n    ...     ZeroDivisionError: integer division or modulo by zero\n    ...     '''\n    >>> test = doctest.DocTestFinder().find(f)[0]\n    >>> doctest.DocTestRunner(verbose=False).run(test)\n    TestResults(failed=0, attempted=2)\n\nAn example may not generate output before it raises an exception; if\nit does, then the traceback message will not be recognized as\nsignaling an expected exception, so the example will be reported as an\nunexpected exception:\n\n    >>> def f(x):\n    ...     '''\n    ...     >>> x = 12\n    ...     >>> print('pre-exception output', x//0)\n    ...     pre-exception output\n    ...     Traceback (most recent call last):\n    ...     ZeroDivisionError: integer division or modulo by zero\n    ...     '''\n    >>> test = doctest.DocTestFinder().find(f)[0]\n    >>> doctest.DocTestRunner(verbose=False).run(test)\n    ... # doctest: +ELLIPSIS\n    **********************************************************************\n    File ..., line 4, in f\n    Failed example:\n        print('pre-exception output', x//0)\n    Exception raised:\n        ...\n        ZeroDivisionError: integer division or modulo by zero\n    TestResults(failed=1, attempted=2)\n\nException messages may contain newlines:\n\n    >>> def f(x):\n    ...     r'''\n    ...     >>> raise ValueError('multi\\nline\\nmessage')\n    ...     Traceback (most recent call last):\n    ...     ValueError: multi\n    ...     line\n    ...     message\n    ...     '''\n    >>> test = doctest.DocTestFinder().find(f)[0]\n    >>> doctest.DocTestRunner(verbose=False).run(test)\n    TestResults(failed=0, attempted=1)\n\nIf an exception is expected, but an exception with the wrong type or\nmessage is raised, then it is reported as a failure:\n\n    >>> def f(x):\n    ...     r'''\n    ...     >>> raise ValueError('message')\n    ...     Traceback (most recent call last):\n    ...     ValueError: wrong message\n    ...     '''\n    >>> test = doctest.DocTestFinder().find(f)[0]\n    >>> doctest.DocTestRunner(verbose=False).run(test)\n    ... # doctest: +ELLIPSIS\n    **********************************************************************\n    File ..., line 3, in f\n    Failed example:\n        raise ValueError('message')\n    Expected:\n        Traceback (most recent call last):\n        ValueError: wrong message\n    Got:\n        Traceback (most recent call last):\n        ...\n        ValueError: message\n    TestResults(failed=1, attempted=1)\n\nHowever, IGNORE_EXCEPTION_DETAIL can be used to allow a mismatch in the\ndetail:\n\n    >>> def f(x):\n    ...     r'''\n    ...     >>> raise ValueError('message') #doctest: +IGNORE_EXCEPTION_DETAIL\n    ...     Traceback (most recent call last):\n    ...     ValueError: wrong message\n    ...     '''\n    >>> test = doctest.DocTestFinder().find(f)[0]\n    >>> doctest.DocTestRunner(verbose=False).run(test)\n    TestResults(failed=0, attempted=1)\n\nIGNORE_EXCEPTION_DETAIL also ignores difference in exception formatting\nbetween Python versions. For example, in Python 2.x, the module path of\nthe exception is not in the output, but this will fail under Python 3:\n\n    >>> def f(x):\n    ...     r'''\n    ...     >>> from http.client import HTTPException\n    ...     >>> raise HTTPException('message')\n    ...     Traceback (most recent call last):\n    ...     HTTPException: message\n    ...     '''\n    >>> test = doctest.DocTestFinder().find(f)[0]\n    >>> doctest.DocTestRunner(verbose=False).run(test)\n    ... # doctest: +ELLIPSIS\n    **********************************************************************\n    File ..., line 4, in f\n    Failed example:\n        raise HTTPException('message')\n    Expected:\n        Traceback (most recent call last):\n        HTTPException: message\n    Got:\n        Traceback (most recent call last):\n        ...\n        http.client.HTTPException: message\n    TestResults(failed=1, attempted=2)\n\nBut in Python 3 the module path is included, and therefore a test must look\nlike the following test to succeed in Python 3. But that test will fail under\nPython 2.\n\n    >>> def f(x):\n    ...     r'''\n    ...     >>> from http.client import HTTPException\n    ...     >>> raise HTTPException('message')\n    ...     Traceback (most recent call last):\n    ...     http.client.HTTPException: message\n    ...     '''\n    >>> test = doctest.DocTestFinder().find(f)[0]\n    >>> doctest.DocTestRunner(verbose=False).run(test)\n    TestResults(failed=0, attempted=2)\n\nHowever, with IGNORE_EXCEPTION_DETAIL, the module name of the exception\n(or its unexpected absence) will be ignored:\n\n    >>> def f(x):\n    ...     r'''\n    ...     >>> from http.client import HTTPException\n    ...     >>> raise HTTPException('message') #doctest: +IGNORE_EXCEPTION_DETAIL\n    ...     Traceback (most recent call last):\n    ...     HTTPException: message\n    ...     '''\n    >>> test = doctest.DocTestFinder().find(f)[0]\n    >>> doctest.DocTestRunner(verbose=False).run(test)\n    TestResults(failed=0, attempted=2)\n\nThe module path will be completely ignored, so two different module paths will\nstill pass if IGNORE_EXCEPTION_DETAIL is given. This is intentional, so it can\nbe used when exceptions have changed module.\n\n    >>> def f(x):\n    ...     r'''\n    ...     >>> from http.client import HTTPException\n    ...     >>> raise HTTPException('message') #doctest: +IGNORE_EXCEPTION_DETAIL\n    ...     Traceback (most recent call last):\n    ...     foo.bar.HTTPException: message\n    ...     '''\n    >>> test = doctest.DocTestFinder().find(f)[0]\n    >>> doctest.DocTestRunner(verbose=False).run(test)\n    TestResults(failed=0, attempted=2)\n\nBut IGNORE_EXCEPTION_DETAIL does not allow a mismatch in the exception type:\n\n    >>> def f(x):\n    ...     r'''\n    ...     >>> raise ValueError('message') #doctest: +IGNORE_EXCEPTION_DETAIL\n    ...     Traceback (most recent call last):\n    ...     TypeError: wrong type\n    ...     '''\n    >>> test = doctest.DocTestFinder().find(f)[0]\n    >>> doctest.DocTestRunner(verbose=False).run(test)\n    ... # doctest: +ELLIPSIS\n    **********************************************************************\n    File ..., line 3, in f\n    Failed example:\n        raise ValueError('message') #doctest: +IGNORE_EXCEPTION_DETAIL\n    Expected:\n        Traceback (most recent call last):\n        TypeError: wrong type\n    Got:\n        Traceback (most recent call last):\n        ...\n        ValueError: message\n    TestResults(failed=1, attempted=1)\n\nIf the exception does not have a message, you can still use\nIGNORE_EXCEPTION_DETAIL to normalize the modules between Python 2 and 3:\n\n    >>> def f(x):\n    ...     r'''\n    ...     >>> from http.client import HTTPException\n    ...     >>> raise HTTPException() #doctest: +IGNORE_EXCEPTION_DETAIL\n    ...     Traceback (most recent call last):\n    ...     foo.bar.HTTPException\n    ...     '''\n    >>> test = doctest.DocTestFinder().find(f)[0]\n    >>> doctest.DocTestRunner(verbose=False).run(test)\n    TestResults(failed=0, attempted=2)\n\nNote that a trailing colon doesn't matter either:\n\n    >>> def f(x):\n    ...     r'''\n    ...     >>> from http.client import HTTPException\n    ...     >>> raise HTTPException() #doctest: +IGNORE_EXCEPTION_DETAIL\n    ...     Traceback (most recent call last):\n    ...     foo.bar.HTTPException:\n    ...     '''\n    >>> test = doctest.DocTestFinder().find(f)[0]\n    >>> doctest.DocTestRunner(verbose=False).run(test)\n    TestResults(failed=0, attempted=2)\n\nIf an exception is raised but not expected, then it is reported as an\nunexpected exception:\n\n    >>> def f(x):\n    ...     r'''\n    ...     >>> 1//0\n    ...     0\n    ...     '''\n    >>> test = doctest.DocTestFinder().find(f)[0]\n    >>> doctest.DocTestRunner(verbose=False).run(test)\n    ... # doctest: +ELLIPSIS\n    **********************************************************************\n    File ..., line 3, in f\n    Failed example:\n        1//0\n    Exception raised:\n        Traceback (most recent call last):\n        ...\n        ZeroDivisionError: integer division or modulo by zero\n    TestResults(failed=1, attempted=1)\n"

    def displayhook():
        "\nTest that changing sys.displayhook doesn't matter for doctest.\n\n    >>> import sys\n    >>> orig_displayhook = sys.displayhook\n    >>> def my_displayhook(x):\n    ...     print('hi!')\n    >>> sys.displayhook = my_displayhook\n    >>> def f():\n    ...     '''\n    ...     >>> 3\n    ...     3\n    ...     '''\n    >>> test = doctest.DocTestFinder().find(f)[0]\n    >>> r = doctest.DocTestRunner(verbose=False).run(test)\n    >>> post_displayhook = sys.displayhook\n\n    We need to restore sys.displayhook now, so that we'll be able to test\n    results.\n\n    >>> sys.displayhook = orig_displayhook\n\n    Ok, now we can check that everything is ok.\n\n    >>> r\n    TestResults(failed=0, attempted=1)\n    >>> post_displayhook is my_displayhook\n    True\n"

    def optionflags():
        '\nTests of `DocTestRunner`\'s option flag handling.\n\nSeveral option flags can be used to customize the behavior of the test\nrunner.  These are defined as module constants in doctest, and passed\nto the DocTestRunner constructor (multiple constants should be ORed\ntogether).\n\nThe DONT_ACCEPT_TRUE_FOR_1 flag disables matches between True/False\nand 1/0:\n\n    >>> def f(x):\n    ...     \'>>> True\\n1\\n\'\n\n    >>> # Without the flag:\n    >>> test = doctest.DocTestFinder().find(f)[0]\n    >>> doctest.DocTestRunner(verbose=False).run(test)\n    TestResults(failed=0, attempted=1)\n\n    >>> # With the flag:\n    >>> test = doctest.DocTestFinder().find(f)[0]\n    >>> flags = doctest.DONT_ACCEPT_TRUE_FOR_1\n    >>> doctest.DocTestRunner(verbose=False, optionflags=flags).run(test)\n    ... # doctest: +ELLIPSIS\n    **********************************************************************\n    File ..., line 2, in f\n    Failed example:\n        True\n    Expected:\n        1\n    Got:\n        True\n    TestResults(failed=1, attempted=1)\n\nThe DONT_ACCEPT_BLANKLINE flag disables the match between blank lines\nand the \'<BLANKLINE>\' marker:\n\n    >>> def f(x):\n    ...     \'>>> print("a\\\\n\\\\nb")\\na\\n<BLANKLINE>\\nb\\n\'\n\n    >>> # Without the flag:\n    >>> test = doctest.DocTestFinder().find(f)[0]\n    >>> doctest.DocTestRunner(verbose=False).run(test)\n    TestResults(failed=0, attempted=1)\n\n    >>> # With the flag:\n    >>> test = doctest.DocTestFinder().find(f)[0]\n    >>> flags = doctest.DONT_ACCEPT_BLANKLINE\n    >>> doctest.DocTestRunner(verbose=False, optionflags=flags).run(test)\n    ... # doctest: +ELLIPSIS\n    **********************************************************************\n    File ..., line 2, in f\n    Failed example:\n        print("a\\n\\nb")\n    Expected:\n        a\n        <BLANKLINE>\n        b\n    Got:\n        a\n    <BLANKLINE>\n        b\n    TestResults(failed=1, attempted=1)\n\nThe NORMALIZE_WHITESPACE flag causes all sequences of whitespace to be\ntreated as equal:\n\n    >>> def f(x):\n    ...     \'>>> print(1, 2, 3)\\n  1   2\\n 3\'\n\n    >>> # Without the flag:\n    >>> test = doctest.DocTestFinder().find(f)[0]\n    >>> doctest.DocTestRunner(verbose=False).run(test)\n    ... # doctest: +ELLIPSIS\n    **********************************************************************\n    File ..., line 2, in f\n    Failed example:\n        print(1, 2, 3)\n    Expected:\n          1   2\n         3\n    Got:\n        1 2 3\n    TestResults(failed=1, attempted=1)\n\n    >>> # With the flag:\n    >>> test = doctest.DocTestFinder().find(f)[0]\n    >>> flags = doctest.NORMALIZE_WHITESPACE\n    >>> doctest.DocTestRunner(verbose=False, optionflags=flags).run(test)\n    TestResults(failed=0, attempted=1)\n\n    An example from the docs:\n    >>> print(list(range(20))) #doctest: +NORMALIZE_WHITESPACE\n    [0,   1,  2,  3,  4,  5,  6,  7,  8,  9,\n    10,  11, 12, 13, 14, 15, 16, 17, 18, 19]\n\nThe ELLIPSIS flag causes ellipsis marker ("...") in the expected\noutput to match any substring in the actual output:\n\n    >>> def f(x):\n    ...     \'>>> print(list(range(15)))\\n[0, 1, 2, ..., 14]\\n\'\n\n    >>> # Without the flag:\n    >>> test = doctest.DocTestFinder().find(f)[0]\n    >>> doctest.DocTestRunner(verbose=False).run(test)\n    ... # doctest: +ELLIPSIS\n    **********************************************************************\n    File ..., line 2, in f\n    Failed example:\n        print(list(range(15)))\n    Expected:\n        [0, 1, 2, ..., 14]\n    Got:\n        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]\n    TestResults(failed=1, attempted=1)\n\n    >>> # With the flag:\n    >>> test = doctest.DocTestFinder().find(f)[0]\n    >>> flags = doctest.ELLIPSIS\n    >>> doctest.DocTestRunner(verbose=False, optionflags=flags).run(test)\n    TestResults(failed=0, attempted=1)\n\n    ... also matches nothing:\n\n    >>> if 1:\n    ...     for i in range(100):\n    ...         print(i**2, end=\' \') #doctest: +ELLIPSIS\n    ...     print(\'!\')\n    0 1...4...9 16 ... 36 49 64 ... 9801 !\n\n    ... can be surprising; e.g., this test passes:\n\n    >>> if 1:  #doctest: +ELLIPSIS\n    ...     for i in range(20):\n    ...         print(i, end=\' \')\n    ...     print(20)\n    0 1 2 ...1...2...0\n\n    Examples from the docs:\n\n    >>> print(list(range(20))) # doctest:+ELLIPSIS\n    [0, 1, ..., 18, 19]\n\n    >>> print(list(range(20))) # doctest: +ELLIPSIS\n    ...                 # doctest: +NORMALIZE_WHITESPACE\n    [0,    1, ...,   18,    19]\n\nThe SKIP flag causes an example to be skipped entirely.  I.e., the\nexample is not run.  It can be useful in contexts where doctest\nexamples serve as both documentation and test cases, and an example\nshould be included for documentation purposes, but should not be\nchecked (e.g., because its output is random, or depends on resources\nwhich would be unavailable.)  The SKIP flag can also be used for\n\'commenting out\' broken examples.\n\n    >>> import unavailable_resource           # doctest: +SKIP\n    >>> unavailable_resource.do_something()   # doctest: +SKIP\n    >>> unavailable_resource.blow_up()        # doctest: +SKIP\n    Traceback (most recent call last):\n        ...\n    UncheckedBlowUpError:  Nobody checks me.\n\n    >>> import random\n    >>> print(random.random()) # doctest: +SKIP\n    0.721216923889\n\nThe REPORT_UDIFF flag causes failures that involve multi-line expected\nand actual outputs to be displayed using a unified diff:\n\n    >>> def f(x):\n    ...     r\'\'\'\n    ...     >>> print(\'\\n\'.join(\'abcdefg\'))\n    ...     a\n    ...     B\n    ...     c\n    ...     d\n    ...     f\n    ...     g\n    ...     h\n    ...     \'\'\'\n\n    >>> # Without the flag:\n    >>> test = doctest.DocTestFinder().find(f)[0]\n    >>> doctest.DocTestRunner(verbose=False).run(test)\n    ... # doctest: +ELLIPSIS\n    **********************************************************************\n    File ..., line 3, in f\n    Failed example:\n        print(\'\\n\'.join(\'abcdefg\'))\n    Expected:\n        a\n        B\n        c\n        d\n        f\n        g\n        h\n    Got:\n        a\n        b\n        c\n        d\n        e\n        f\n        g\n    TestResults(failed=1, attempted=1)\n\n    >>> # With the flag:\n    >>> test = doctest.DocTestFinder().find(f)[0]\n    >>> flags = doctest.REPORT_UDIFF\n    >>> doctest.DocTestRunner(verbose=False, optionflags=flags).run(test)\n    ... # doctest: +ELLIPSIS\n    **********************************************************************\n    File ..., line 3, in f\n    Failed example:\n        print(\'\\n\'.join(\'abcdefg\'))\n    Differences (unified diff with -expected +actual):\n        @@ -1,7 +1,7 @@\n         a\n        -B\n        +b\n         c\n         d\n        +e\n         f\n         g\n        -h\n    TestResults(failed=1, attempted=1)\n\nThe REPORT_CDIFF flag causes failures that involve multi-line expected\nand actual outputs to be displayed using a context diff:\n\n    >>> # Reuse f() from the REPORT_UDIFF example, above.\n    >>> test = doctest.DocTestFinder().find(f)[0]\n    >>> flags = doctest.REPORT_CDIFF\n    >>> doctest.DocTestRunner(verbose=False, optionflags=flags).run(test)\n    ... # doctest: +ELLIPSIS\n    **********************************************************************\n    File ..., line 3, in f\n    Failed example:\n        print(\'\\n\'.join(\'abcdefg\'))\n    Differences (context diff with expected followed by actual):\n        ***************\n        *** 1,7 ****\n          a\n        ! B\n          c\n          d\n          f\n          g\n        - h\n        --- 1,7 ----\n          a\n        ! b\n          c\n          d\n        + e\n          f\n          g\n    TestResults(failed=1, attempted=1)\n\n\nThe REPORT_NDIFF flag causes failures to use the difflib.Differ algorithm\nused by the popular ndiff.py utility.  This does intraline difference\nmarking, as well as interline differences.\n\n    >>> def f(x):\n    ...     r\'\'\'\n    ...     >>> print("a b  c d e f g h i   j k l m")\n    ...     a b c d e f g h i j k 1 m\n    ...     \'\'\'\n    >>> test = doctest.DocTestFinder().find(f)[0]\n    >>> flags = doctest.REPORT_NDIFF\n    >>> doctest.DocTestRunner(verbose=False, optionflags=flags).run(test)\n    ... # doctest: +ELLIPSIS\n    **********************************************************************\n    File ..., line 3, in f\n    Failed example:\n        print("a b  c d e f g h i   j k l m")\n    Differences (ndiff with -expected +actual):\n        - a b c d e f g h i j k 1 m\n        ?                       ^\n        + a b  c d e f g h i   j k l m\n        ?     +              ++    ^\n    TestResults(failed=1, attempted=1)\n\nThe REPORT_ONLY_FIRST_FAILURE suppresses result output after the first\nfailing example:\n\n    >>> def f(x):\n    ...     r\'\'\'\n    ...     >>> print(1) # first success\n    ...     1\n    ...     >>> print(2) # first failure\n    ...     200\n    ...     >>> print(3) # second failure\n    ...     300\n    ...     >>> print(4) # second success\n    ...     4\n    ...     >>> print(5) # third failure\n    ...     500\n    ...     \'\'\'\n    >>> test = doctest.DocTestFinder().find(f)[0]\n    >>> flags = doctest.REPORT_ONLY_FIRST_FAILURE\n    >>> doctest.DocTestRunner(verbose=False, optionflags=flags).run(test)\n    ... # doctest: +ELLIPSIS\n    **********************************************************************\n    File ..., line 5, in f\n    Failed example:\n        print(2) # first failure\n    Expected:\n        200\n    Got:\n        2\n    TestResults(failed=3, attempted=5)\n\nHowever, output from `report_start` is not suppressed:\n\n    >>> doctest.DocTestRunner(verbose=True, optionflags=flags).run(test)\n    ... # doctest: +ELLIPSIS\n    Trying:\n        print(1) # first success\n    Expecting:\n        1\n    ok\n    Trying:\n        print(2) # first failure\n    Expecting:\n        200\n    **********************************************************************\n    File ..., line 5, in f\n    Failed example:\n        print(2) # first failure\n    Expected:\n        200\n    Got:\n        2\n    TestResults(failed=3, attempted=5)\n\nThe FAIL_FAST flag causes the runner to exit after the first failing example,\nso subsequent examples are not even attempted:\n\n    >>> flags = doctest.FAIL_FAST\n    >>> doctest.DocTestRunner(verbose=False, optionflags=flags).run(test)\n    ... # doctest: +ELLIPSIS\n    **********************************************************************\n    File ..., line 5, in f\n    Failed example:\n        print(2) # first failure\n    Expected:\n        200\n    Got:\n        2\n    TestResults(failed=1, attempted=2)\n\nSpecifying both FAIL_FAST and REPORT_ONLY_FIRST_FAILURE is equivalent to\nFAIL_FAST only:\n\n    >>> flags = doctest.FAIL_FAST | doctest.REPORT_ONLY_FIRST_FAILURE\n    >>> doctest.DocTestRunner(verbose=False, optionflags=flags).run(test)\n    ... # doctest: +ELLIPSIS\n    **********************************************************************\n    File ..., line 5, in f\n    Failed example:\n        print(2) # first failure\n    Expected:\n        200\n    Got:\n        2\n    TestResults(failed=1, attempted=2)\n\nFor the purposes of both REPORT_ONLY_FIRST_FAILURE and FAIL_FAST, unexpected\nexceptions count as failures:\n\n    >>> def f(x):\n    ...     r\'\'\'\n    ...     >>> print(1) # first success\n    ...     1\n    ...     >>> raise ValueError(2) # first failure\n    ...     200\n    ...     >>> print(3) # second failure\n    ...     300\n    ...     >>> print(4) # second success\n    ...     4\n    ...     >>> print(5) # third failure\n    ...     500\n    ...     \'\'\'\n    >>> test = doctest.DocTestFinder().find(f)[0]\n    >>> flags = doctest.REPORT_ONLY_FIRST_FAILURE\n    >>> doctest.DocTestRunner(verbose=False, optionflags=flags).run(test)\n    ... # doctest: +ELLIPSIS\n    **********************************************************************\n    File ..., line 5, in f\n    Failed example:\n        raise ValueError(2) # first failure\n    Exception raised:\n        ...\n        ValueError: 2\n    TestResults(failed=3, attempted=5)\n    >>> flags = doctest.FAIL_FAST\n    >>> doctest.DocTestRunner(verbose=False, optionflags=flags).run(test)\n    ... # doctest: +ELLIPSIS\n    **********************************************************************\n    File ..., line 5, in f\n    Failed example:\n        raise ValueError(2) # first failure\n    Exception raised:\n        ...\n        ValueError: 2\n    TestResults(failed=1, attempted=2)\n\nNew option flags can also be registered, via register_optionflag().  Here\nwe reach into doctest\'s internals a bit.\n\n    >>> unlikely = "UNLIKELY_OPTION_NAME"\n    >>> unlikely in doctest.OPTIONFLAGS_BY_NAME\n    False\n    >>> new_flag_value = doctest.register_optionflag(unlikely)\n    >>> unlikely in doctest.OPTIONFLAGS_BY_NAME\n    True\n\nBefore 2.4.4/2.5, registering a name more than once erroneously created\nmore than one flag value.  Here we verify that\'s fixed:\n\n    >>> redundant_flag_value = doctest.register_optionflag(unlikely)\n    >>> redundant_flag_value == new_flag_value\n    True\n\nClean up.\n    >>> del doctest.OPTIONFLAGS_BY_NAME[unlikely]\n\n    '

    def option_directives():
        "\nTests of `DocTestRunner`'s option directive mechanism.\n\nOption directives can be used to turn option flags on or off for a\nsingle example.  To turn an option on for an example, follow that\nexample with a comment of the form ``# doctest: +OPTION``:\n\n    >>> def f(x): r'''\n    ...     >>> print(list(range(10)))      # should fail: no ellipsis\n    ...     [0, 1, ..., 9]\n    ...\n    ...     >>> print(list(range(10)))      # doctest: +ELLIPSIS\n    ...     [0, 1, ..., 9]\n    ...     '''\n    >>> test = doctest.DocTestFinder().find(f)[0]\n    >>> doctest.DocTestRunner(verbose=False).run(test)\n    ... # doctest: +ELLIPSIS\n    **********************************************************************\n    File ..., line 2, in f\n    Failed example:\n        print(list(range(10)))      # should fail: no ellipsis\n    Expected:\n        [0, 1, ..., 9]\n    Got:\n        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n    TestResults(failed=1, attempted=2)\n\nTo turn an option off for an example, follow that example with a\ncomment of the form ``# doctest: -OPTION``:\n\n    >>> def f(x): r'''\n    ...     >>> print(list(range(10)))\n    ...     [0, 1, ..., 9]\n    ...\n    ...     >>> # should fail: no ellipsis\n    ...     >>> print(list(range(10)))      # doctest: -ELLIPSIS\n    ...     [0, 1, ..., 9]\n    ...     '''\n    >>> test = doctest.DocTestFinder().find(f)[0]\n    >>> doctest.DocTestRunner(verbose=False,\n    ...                       optionflags=doctest.ELLIPSIS).run(test)\n    ... # doctest: +ELLIPSIS\n    **********************************************************************\n    File ..., line 6, in f\n    Failed example:\n        print(list(range(10)))      # doctest: -ELLIPSIS\n    Expected:\n        [0, 1, ..., 9]\n    Got:\n        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n    TestResults(failed=1, attempted=2)\n\nOption directives affect only the example that they appear with; they\ndo not change the options for surrounding examples:\n\n    >>> def f(x): r'''\n    ...     >>> print(list(range(10)))      # Should fail: no ellipsis\n    ...     [0, 1, ..., 9]\n    ...\n    ...     >>> print(list(range(10)))      # doctest: +ELLIPSIS\n    ...     [0, 1, ..., 9]\n    ...\n    ...     >>> print(list(range(10)))      # Should fail: no ellipsis\n    ...     [0, 1, ..., 9]\n    ...     '''\n    >>> test = doctest.DocTestFinder().find(f)[0]\n    >>> doctest.DocTestRunner(verbose=False).run(test)\n    ... # doctest: +ELLIPSIS\n    **********************************************************************\n    File ..., line 2, in f\n    Failed example:\n        print(list(range(10)))      # Should fail: no ellipsis\n    Expected:\n        [0, 1, ..., 9]\n    Got:\n        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n    **********************************************************************\n    File ..., line 8, in f\n    Failed example:\n        print(list(range(10)))      # Should fail: no ellipsis\n    Expected:\n        [0, 1, ..., 9]\n    Got:\n        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n    TestResults(failed=2, attempted=3)\n\nMultiple options may be modified by a single option directive.  They\nmay be separated by whitespace, commas, or both:\n\n    >>> def f(x): r'''\n    ...     >>> print(list(range(10)))      # Should fail\n    ...     [0, 1,  ...,   9]\n    ...     >>> print(list(range(10)))      # Should succeed\n    ...     ... # doctest: +ELLIPSIS +NORMALIZE_WHITESPACE\n    ...     [0, 1,  ...,   9]\n    ...     '''\n    >>> test = doctest.DocTestFinder().find(f)[0]\n    >>> doctest.DocTestRunner(verbose=False).run(test)\n    ... # doctest: +ELLIPSIS\n    **********************************************************************\n    File ..., line 2, in f\n    Failed example:\n        print(list(range(10)))      # Should fail\n    Expected:\n        [0, 1,  ...,   9]\n    Got:\n        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n    TestResults(failed=1, attempted=2)\n\n    >>> def f(x): r'''\n    ...     >>> print(list(range(10)))      # Should fail\n    ...     [0, 1,  ...,   9]\n    ...     >>> print(list(range(10)))      # Should succeed\n    ...     ... # doctest: +ELLIPSIS,+NORMALIZE_WHITESPACE\n    ...     [0, 1,  ...,   9]\n    ...     '''\n    >>> test = doctest.DocTestFinder().find(f)[0]\n    >>> doctest.DocTestRunner(verbose=False).run(test)\n    ... # doctest: +ELLIPSIS\n    **********************************************************************\n    File ..., line 2, in f\n    Failed example:\n        print(list(range(10)))      # Should fail\n    Expected:\n        [0, 1,  ...,   9]\n    Got:\n        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n    TestResults(failed=1, attempted=2)\n\n    >>> def f(x): r'''\n    ...     >>> print(list(range(10)))      # Should fail\n    ...     [0, 1,  ...,   9]\n    ...     >>> print(list(range(10)))      # Should succeed\n    ...     ... # doctest: +ELLIPSIS, +NORMALIZE_WHITESPACE\n    ...     [0, 1,  ...,   9]\n    ...     '''\n    >>> test = doctest.DocTestFinder().find(f)[0]\n    >>> doctest.DocTestRunner(verbose=False).run(test)\n    ... # doctest: +ELLIPSIS\n    **********************************************************************\n    File ..., line 2, in f\n    Failed example:\n        print(list(range(10)))      # Should fail\n    Expected:\n        [0, 1,  ...,   9]\n    Got:\n        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n    TestResults(failed=1, attempted=2)\n\nThe option directive may be put on the line following the source, as\nlong as a continuation prompt is used:\n\n    >>> def f(x): r'''\n    ...     >>> print(list(range(10)))\n    ...     ... # doctest: +ELLIPSIS\n    ...     [0, 1, ..., 9]\n    ...     '''\n    >>> test = doctest.DocTestFinder().find(f)[0]\n    >>> doctest.DocTestRunner(verbose=False).run(test)\n    TestResults(failed=0, attempted=1)\n\nFor examples with multi-line source, the option directive may appear\nat the end of any line:\n\n    >>> def f(x): r'''\n    ...     >>> for x in range(10): # doctest: +ELLIPSIS\n    ...     ...     print(' ', x, end='', sep='')\n    ...      0 1 2 ... 9\n    ...\n    ...     >>> for x in range(10):\n    ...     ...     print(' ', x, end='', sep='') # doctest: +ELLIPSIS\n    ...      0 1 2 ... 9\n    ...     '''\n    >>> test = doctest.DocTestFinder().find(f)[0]\n    >>> doctest.DocTestRunner(verbose=False).run(test)\n    TestResults(failed=0, attempted=2)\n\nIf more than one line of an example with multi-line source has an\noption directive, then they are combined:\n\n    >>> def f(x): r'''\n    ...     Should fail (option directive not on the last line):\n    ...         >>> for x in range(10): # doctest: +ELLIPSIS\n    ...         ...     print(x, end=' ') # doctest: +NORMALIZE_WHITESPACE\n    ...         0  1    2...9\n    ...     '''\n    >>> test = doctest.DocTestFinder().find(f)[0]\n    >>> doctest.DocTestRunner(verbose=False).run(test)\n    TestResults(failed=0, attempted=1)\n\nIt is an error to have a comment of the form ``# doctest:`` that is\n*not* followed by words of the form ``+OPTION`` or ``-OPTION``, where\n``OPTION`` is an option that has been registered with\n`register_option`:\n\n    >>> # Error: Option not registered\n    >>> s = '>>> print(12)  #doctest: +BADOPTION'\n    >>> test = doctest.DocTestParser().get_doctest(s, {}, 's', 's.py', 0)\n    Traceback (most recent call last):\n    ValueError: line 1 of the doctest for s has an invalid option: '+BADOPTION'\n\n    >>> # Error: No + or - prefix\n    >>> s = '>>> print(12)  #doctest: ELLIPSIS'\n    >>> test = doctest.DocTestParser().get_doctest(s, {}, 's', 's.py', 0)\n    Traceback (most recent call last):\n    ValueError: line 1 of the doctest for s has an invalid option: 'ELLIPSIS'\n\nIt is an error to use an option directive on a line that contains no\nsource:\n\n    >>> s = '>>> # doctest: +ELLIPSIS'\n    >>> test = doctest.DocTestParser().get_doctest(s, {}, 's', 's.py', 0)\n    Traceback (most recent call last):\n    ValueError: line 0 of the doctest for s has an option directive on a line with no example: '# doctest: +ELLIPSIS'\n"

def test_testsource():
    "\nUnit tests for `testsource()`.\n\nThe testsource() function takes a module and a name, finds the (first)\ntest with that name in that module, and converts it to a script. The\nexample code is converted to regular Python code.  The surrounding\nwords and expected output are converted to comments:\n\n    >>> import test.test_doctest\n    >>> name = 'test.test_doctest.sample_func'\n    >>> print(doctest.testsource(test.test_doctest, name))\n    # Blah blah\n    #\n    print(sample_func(22))\n    # Expected:\n    ## 44\n    #\n    # Yee ha!\n    <BLANKLINE>\n\n    >>> name = 'test.test_doctest.SampleNewStyleClass'\n    >>> print(doctest.testsource(test.test_doctest, name))\n    print('1\\n2\\n3')\n    # Expected:\n    ## 1\n    ## 2\n    ## 3\n    <BLANKLINE>\n\n    >>> name = 'test.test_doctest.SampleClass.a_classmethod'\n    >>> print(doctest.testsource(test.test_doctest, name))\n    print(SampleClass.a_classmethod(10))\n    # Expected:\n    ## 12\n    print(SampleClass(0).a_classmethod(10))\n    # Expected:\n    ## 12\n    <BLANKLINE>\n"

def test_debug():
    "\n\nCreate a docstring that we want to debug:\n\n    >>> s = '''\n    ...     >>> x = 12\n    ...     >>> print(x)\n    ...     12\n    ...     '''\n\nCreate some fake stdin input, to feed to the debugger:\n\n    >>> real_stdin = sys.stdin\n    >>> sys.stdin = _FakeInput(['next', 'print(x)', 'continue'])\n\nRun the debugger on the docstring, and then restore sys.stdin.\n\n    >>> try: doctest.debug_src(s)\n    ... finally: sys.stdin = real_stdin\n    > <string>(1)<module>()\n    (Pdb) next\n    12\n    --Return--\n    > <string>(1)<module>()->None\n    (Pdb) print(x)\n    12\n    (Pdb) continue\n\n"
if ((not hasattr(sys, 'gettrace')) or (not sys.gettrace())):

    def test_pdb_set_trace():
        'Using pdb.set_trace from a doctest.\n\n        You can use pdb.set_trace from a doctest.  To do so, you must\n        retrieve the set_trace function from the pdb module at the time\n        you use it.  The doctest module changes sys.stdout so that it can\n        capture program output.  It also temporarily replaces pdb.set_trace\n        with a version that restores stdout.  This is necessary for you to\n        see debugger output.\n\n          >>> doc = \'\'\'\n          ... >>> x = 42\n          ... >>> raise Exception(\'clé\')\n          ... Traceback (most recent call last):\n          ... Exception: clé\n          ... >>> import pdb; pdb.set_trace()\n          ... \'\'\'\n          >>> parser = doctest.DocTestParser()\n          >>> test = parser.get_doctest(doc, {}, "foo-bar@baz", "foo-bar@baz.py", 0)\n          >>> runner = doctest.DocTestRunner(verbose=False)\n\n        To demonstrate this, we\'ll create a fake standard input that\n        captures our debugger input:\n\n          >>> real_stdin = sys.stdin\n          >>> sys.stdin = _FakeInput([\n          ...    \'print(x)\',  # print data defined by the example\n          ...    \'continue\', # stop debugging\n          ...    \'\'])\n\n          >>> try: runner.run(test)\n          ... finally: sys.stdin = real_stdin\n          --Return--\n          > <doctest foo-bar@baz[2]>(1)<module>()->None\n          -> import pdb; pdb.set_trace()\n          (Pdb) print(x)\n          42\n          (Pdb) continue\n          TestResults(failed=0, attempted=3)\n\n          You can also put pdb.set_trace in a function called from a test:\n\n          >>> def calls_set_trace():\n          ...    y=2\n          ...    import pdb; pdb.set_trace()\n\n          >>> doc = \'\'\'\n          ... >>> x=1\n          ... >>> calls_set_trace()\n          ... \'\'\'\n          >>> test = parser.get_doctest(doc, globals(), "foo-bar@baz", "foo-bar@baz.py", 0)\n          >>> real_stdin = sys.stdin\n          >>> sys.stdin = _FakeInput([\n          ...    \'print(y)\',  # print data defined in the function\n          ...    \'up\',       # out of function\n          ...    \'print(x)\',  # print data defined by the example\n          ...    \'continue\', # stop debugging\n          ...    \'\'])\n\n          >>> try:\n          ...     runner.run(test)\n          ... finally:\n          ...     sys.stdin = real_stdin\n          --Return--\n          > <doctest test.test_doctest.test_pdb_set_trace[7]>(3)calls_set_trace()->None\n          -> import pdb; pdb.set_trace()\n          (Pdb) print(y)\n          2\n          (Pdb) up\n          > <doctest foo-bar@baz[1]>(1)<module>()\n          -> calls_set_trace()\n          (Pdb) print(x)\n          1\n          (Pdb) continue\n          TestResults(failed=0, attempted=2)\n\n        During interactive debugging, source code is shown, even for\n        doctest examples:\n\n          >>> doc = \'\'\'\n          ... >>> def f(x):\n          ... ...     g(x*2)\n          ... >>> def g(x):\n          ... ...     print(x+3)\n          ... ...     import pdb; pdb.set_trace()\n          ... >>> f(3)\n          ... \'\'\'\n          >>> test = parser.get_doctest(doc, globals(), "foo-bar@baz", "foo-bar@baz.py", 0)\n          >>> real_stdin = sys.stdin\n          >>> sys.stdin = _FakeInput([\n          ...    \'list\',     # list source from example 2\n          ...    \'next\',     # return from g()\n          ...    \'list\',     # list source from example 1\n          ...    \'next\',     # return from f()\n          ...    \'list\',     # list source from example 3\n          ...    \'continue\', # stop debugging\n          ...    \'\'])\n          >>> try: runner.run(test)\n          ... finally: sys.stdin = real_stdin\n          ... # doctest: +NORMALIZE_WHITESPACE\n          --Return--\n          > <doctest foo-bar@baz[1]>(3)g()->None\n          -> import pdb; pdb.set_trace()\n          (Pdb) list\n            1     def g(x):\n            2         print(x+3)\n            3  ->     import pdb; pdb.set_trace()\n          [EOF]\n          (Pdb) next\n          --Return--\n          > <doctest foo-bar@baz[0]>(2)f()->None\n          -> g(x*2)\n          (Pdb) list\n            1     def f(x):\n            2  ->     g(x*2)\n          [EOF]\n          (Pdb) next\n          --Return--\n          > <doctest foo-bar@baz[2]>(1)<module>()->None\n          -> f(3)\n          (Pdb) list\n            1  -> f(3)\n          [EOF]\n          (Pdb) continue\n          **********************************************************************\n          File "foo-bar@baz.py", line 7, in foo-bar@baz\n          Failed example:\n              f(3)\n          Expected nothing\n          Got:\n              9\n          TestResults(failed=1, attempted=3)\n          '

    def test_pdb_set_trace_nested():
        'This illustrates more-demanding use of set_trace with nested functions.\n\n        >>> class C(object):\n        ...     def calls_set_trace(self):\n        ...         y = 1\n        ...         import pdb; pdb.set_trace()\n        ...         self.f1()\n        ...         y = 2\n        ...     def f1(self):\n        ...         x = 1\n        ...         self.f2()\n        ...         x = 2\n        ...     def f2(self):\n        ...         z = 1\n        ...         z = 2\n\n        >>> calls_set_trace = C().calls_set_trace\n\n        >>> doc = \'\'\'\n        ... >>> a = 1\n        ... >>> calls_set_trace()\n        ... \'\'\'\n        >>> parser = doctest.DocTestParser()\n        >>> runner = doctest.DocTestRunner(verbose=False)\n        >>> test = parser.get_doctest(doc, globals(), "foo-bar@baz", "foo-bar@baz.py", 0)\n        >>> real_stdin = sys.stdin\n        >>> sys.stdin = _FakeInput([\n        ...    \'print(y)\',  # print data defined in the function\n        ...    \'step\', \'step\', \'step\', \'step\', \'step\', \'step\', \'print(z)\',\n        ...    \'up\', \'print(x)\',\n        ...    \'up\', \'print(y)\',\n        ...    \'up\', \'print(foo)\',\n        ...    \'continue\', # stop debugging\n        ...    \'\'])\n\n        >>> try:\n        ...     runner.run(test)\n        ... finally:\n        ...     sys.stdin = real_stdin\n        ... # doctest: +REPORT_NDIFF\n        > <doctest test.test_doctest.test_pdb_set_trace_nested[0]>(5)calls_set_trace()\n        -> self.f1()\n        (Pdb) print(y)\n        1\n        (Pdb) step\n        --Call--\n        > <doctest test.test_doctest.test_pdb_set_trace_nested[0]>(7)f1()\n        -> def f1(self):\n        (Pdb) step\n        > <doctest test.test_doctest.test_pdb_set_trace_nested[0]>(8)f1()\n        -> x = 1\n        (Pdb) step\n        > <doctest test.test_doctest.test_pdb_set_trace_nested[0]>(9)f1()\n        -> self.f2()\n        (Pdb) step\n        --Call--\n        > <doctest test.test_doctest.test_pdb_set_trace_nested[0]>(11)f2()\n        -> def f2(self):\n        (Pdb) step\n        > <doctest test.test_doctest.test_pdb_set_trace_nested[0]>(12)f2()\n        -> z = 1\n        (Pdb) step\n        > <doctest test.test_doctest.test_pdb_set_trace_nested[0]>(13)f2()\n        -> z = 2\n        (Pdb) print(z)\n        1\n        (Pdb) up\n        > <doctest test.test_doctest.test_pdb_set_trace_nested[0]>(9)f1()\n        -> self.f2()\n        (Pdb) print(x)\n        1\n        (Pdb) up\n        > <doctest test.test_doctest.test_pdb_set_trace_nested[0]>(5)calls_set_trace()\n        -> self.f1()\n        (Pdb) print(y)\n        1\n        (Pdb) up\n        > <doctest foo-bar@baz[1]>(1)<module>()\n        -> calls_set_trace()\n        (Pdb) print(foo)\n        *** NameError: name \'foo\' is not defined\n        (Pdb) continue\n        TestResults(failed=0, attempted=2)\n    '

def test_DocTestSuite():
    "DocTestSuite creates a unittest test suite from a doctest.\n\n       We create a Suite by providing a module.  A module can be provided\n       by passing a module object:\n\n         >>> import unittest\n         >>> import test.sample_doctest\n         >>> suite = doctest.DocTestSuite(test.sample_doctest)\n         >>> suite.run(unittest.TestResult())\n         <unittest.result.TestResult run=9 errors=0 failures=4>\n\n       We can also supply the module by name:\n\n         >>> suite = doctest.DocTestSuite('test.sample_doctest')\n         >>> suite.run(unittest.TestResult())\n         <unittest.result.TestResult run=9 errors=0 failures=4>\n\n       The module need not contain any doctest examples:\n\n         >>> suite = doctest.DocTestSuite('test.sample_doctest_no_doctests')\n         >>> suite.run(unittest.TestResult())\n         <unittest.result.TestResult run=0 errors=0 failures=0>\n\n       The module need not contain any docstrings either:\n\n         >>> suite = doctest.DocTestSuite('test.sample_doctest_no_docstrings')\n         >>> suite.run(unittest.TestResult())\n         <unittest.result.TestResult run=0 errors=0 failures=0>\n\n       We can use the current module:\n\n         >>> suite = test.sample_doctest.test_suite()\n         >>> suite.run(unittest.TestResult())\n         <unittest.result.TestResult run=9 errors=0 failures=4>\n\n       We can also provide a DocTestFinder:\n\n         >>> finder = doctest.DocTestFinder()\n         >>> suite = doctest.DocTestSuite('test.sample_doctest',\n         ...                          test_finder=finder)\n         >>> suite.run(unittest.TestResult())\n         <unittest.result.TestResult run=9 errors=0 failures=4>\n\n       The DocTestFinder need not return any tests:\n\n         >>> finder = doctest.DocTestFinder()\n         >>> suite = doctest.DocTestSuite('test.sample_doctest_no_docstrings',\n         ...                          test_finder=finder)\n         >>> suite.run(unittest.TestResult())\n         <unittest.result.TestResult run=0 errors=0 failures=0>\n\n       We can supply global variables.  If we pass globs, they will be\n       used instead of the module globals.  Here we'll pass an empty\n       globals, triggering an extra error:\n\n         >>> suite = doctest.DocTestSuite('test.sample_doctest', globs={})\n         >>> suite.run(unittest.TestResult())\n         <unittest.result.TestResult run=9 errors=0 failures=5>\n\n       Alternatively, we can provide extra globals.  Here we'll make an\n       error go away by providing an extra global variable:\n\n         >>> suite = doctest.DocTestSuite('test.sample_doctest',\n         ...                              extraglobs={'y': 1})\n         >>> suite.run(unittest.TestResult())\n         <unittest.result.TestResult run=9 errors=0 failures=3>\n\n       You can pass option flags.  Here we'll cause an extra error\n       by disabling the blank-line feature:\n\n         >>> suite = doctest.DocTestSuite('test.sample_doctest',\n         ...                      optionflags=doctest.DONT_ACCEPT_BLANKLINE)\n         >>> suite.run(unittest.TestResult())\n         <unittest.result.TestResult run=9 errors=0 failures=5>\n\n       You can supply setUp and tearDown functions:\n\n         >>> def setUp(t):\n         ...     import test.test_doctest\n         ...     test.test_doctest.sillySetup = True\n\n         >>> def tearDown(t):\n         ...     import test.test_doctest\n         ...     del test.test_doctest.sillySetup\n\n       Here, we installed a silly variable that the test expects:\n\n         >>> suite = doctest.DocTestSuite('test.sample_doctest',\n         ...      setUp=setUp, tearDown=tearDown)\n         >>> suite.run(unittest.TestResult())\n         <unittest.result.TestResult run=9 errors=0 failures=3>\n\n       But the tearDown restores sanity:\n\n         >>> import test.test_doctest\n         >>> test.test_doctest.sillySetup\n         Traceback (most recent call last):\n         ...\n         AttributeError: module 'test.test_doctest' has no attribute 'sillySetup'\n\n       The setUp and tearDown functions are passed test objects. Here\n       we'll use the setUp function to supply the missing variable y:\n\n         >>> def setUp(test):\n         ...     test.globs['y'] = 1\n\n         >>> suite = doctest.DocTestSuite('test.sample_doctest', setUp=setUp)\n         >>> suite.run(unittest.TestResult())\n         <unittest.result.TestResult run=9 errors=0 failures=3>\n\n       Here, we didn't need to use a tearDown function because we\n       modified the test globals, which are a copy of the\n       sample_doctest module dictionary.  The test globals are\n       automatically cleared for us after a test.\n       "

def test_DocFileSuite():
    "We can test tests found in text files using a DocFileSuite.\n\n       We create a suite by providing the names of one or more text\n       files that include examples:\n\n         >>> import unittest\n         >>> suite = doctest.DocFileSuite('test_doctest.txt',\n         ...                              'test_doctest2.txt',\n         ...                              'test_doctest4.txt')\n         >>> suite.run(unittest.TestResult())\n         <unittest.result.TestResult run=3 errors=0 failures=2>\n\n       The test files are looked for in the directory containing the\n       calling module.  A package keyword argument can be provided to\n       specify a different relative location.\n\n         >>> import unittest\n         >>> suite = doctest.DocFileSuite('test_doctest.txt',\n         ...                              'test_doctest2.txt',\n         ...                              'test_doctest4.txt',\n         ...                              package='test')\n         >>> suite.run(unittest.TestResult())\n         <unittest.result.TestResult run=3 errors=0 failures=2>\n\n       Support for using a package's __loader__.get_data() is also\n       provided.\n\n         >>> import unittest, pkgutil, test\n         >>> added_loader = False\n         >>> if not hasattr(test, '__loader__'):\n         ...     test.__loader__ = pkgutil.get_loader(test)\n         ...     added_loader = True\n         >>> try:\n         ...     suite = doctest.DocFileSuite('test_doctest.txt',\n         ...                                  'test_doctest2.txt',\n         ...                                  'test_doctest4.txt',\n         ...                                  package='test')\n         ...     suite.run(unittest.TestResult())\n         ... finally:\n         ...     if added_loader:\n         ...         del test.__loader__\n         <unittest.result.TestResult run=3 errors=0 failures=2>\n\n       '/' should be used as a path separator.  It will be converted\n       to a native separator at run time:\n\n         >>> suite = doctest.DocFileSuite('../test/test_doctest.txt')\n         >>> suite.run(unittest.TestResult())\n         <unittest.result.TestResult run=1 errors=0 failures=1>\n\n       If DocFileSuite is used from an interactive session, then files\n       are resolved relative to the directory of sys.argv[0]:\n\n         >>> import types, os.path, test.test_doctest\n         >>> save_argv = sys.argv\n         >>> sys.argv = [test.test_doctest.__file__]\n         >>> suite = doctest.DocFileSuite('test_doctest.txt',\n         ...                              package=types.ModuleType('__main__'))\n         >>> sys.argv = save_argv\n\n       By setting `module_relative=False`, os-specific paths may be\n       used (including absolute paths and paths relative to the\n       working directory):\n\n         >>> # Get the absolute path of the test package.\n         >>> test_doctest_path = os.path.abspath(test.test_doctest.__file__)\n         >>> test_pkg_path = os.path.split(test_doctest_path)[0]\n\n         >>> # Use it to find the absolute path of test_doctest.txt.\n         >>> test_file = os.path.join(test_pkg_path, 'test_doctest.txt')\n\n         >>> suite = doctest.DocFileSuite(test_file, module_relative=False)\n         >>> suite.run(unittest.TestResult())\n         <unittest.result.TestResult run=1 errors=0 failures=1>\n\n       It is an error to specify `package` when `module_relative=False`:\n\n         >>> suite = doctest.DocFileSuite(test_file, module_relative=False,\n         ...                              package='test')\n         Traceback (most recent call last):\n         ValueError: Package may only be specified for module-relative paths.\n\n       You can specify initial global variables:\n\n         >>> suite = doctest.DocFileSuite('test_doctest.txt',\n         ...                              'test_doctest2.txt',\n         ...                              'test_doctest4.txt',\n         ...                              globs={'favorite_color': 'blue'})\n         >>> suite.run(unittest.TestResult())\n         <unittest.result.TestResult run=3 errors=0 failures=1>\n\n       In this case, we supplied a missing favorite color. You can\n       provide doctest options:\n\n         >>> suite = doctest.DocFileSuite('test_doctest.txt',\n         ...                              'test_doctest2.txt',\n         ...                              'test_doctest4.txt',\n         ...                         optionflags=doctest.DONT_ACCEPT_BLANKLINE,\n         ...                              globs={'favorite_color': 'blue'})\n         >>> suite.run(unittest.TestResult())\n         <unittest.result.TestResult run=3 errors=0 failures=2>\n\n       And, you can provide setUp and tearDown functions:\n\n         >>> def setUp(t):\n         ...     import test.test_doctest\n         ...     test.test_doctest.sillySetup = True\n\n         >>> def tearDown(t):\n         ...     import test.test_doctest\n         ...     del test.test_doctest.sillySetup\n\n       Here, we installed a silly variable that the test expects:\n\n         >>> suite = doctest.DocFileSuite('test_doctest.txt',\n         ...                              'test_doctest2.txt',\n         ...                              'test_doctest4.txt',\n         ...                              setUp=setUp, tearDown=tearDown)\n         >>> suite.run(unittest.TestResult())\n         <unittest.result.TestResult run=3 errors=0 failures=1>\n\n       But the tearDown restores sanity:\n\n         >>> import test.test_doctest\n         >>> test.test_doctest.sillySetup\n         Traceback (most recent call last):\n         ...\n         AttributeError: module 'test.test_doctest' has no attribute 'sillySetup'\n\n       The setUp and tearDown functions are passed test objects.\n       Here, we'll use a setUp function to set the favorite color in\n       test_doctest.txt:\n\n         >>> def setUp(test):\n         ...     test.globs['favorite_color'] = 'blue'\n\n         >>> suite = doctest.DocFileSuite('test_doctest.txt', setUp=setUp)\n         >>> suite.run(unittest.TestResult())\n         <unittest.result.TestResult run=1 errors=0 failures=0>\n\n       Here, we didn't need to use a tearDown function because we\n       modified the test globals.  The test globals are\n       automatically cleared for us after a test.\n\n       Tests in a file run using `DocFileSuite` can also access the\n       `__file__` global, which is set to the name of the file\n       containing the tests:\n\n         >>> suite = doctest.DocFileSuite('test_doctest3.txt')\n         >>> suite.run(unittest.TestResult())\n         <unittest.result.TestResult run=1 errors=0 failures=0>\n\n       If the tests contain non-ASCII characters, we have to specify which\n       encoding the file is encoded with. We do so by using the `encoding`\n       parameter:\n\n         >>> suite = doctest.DocFileSuite('test_doctest.txt',\n         ...                              'test_doctest2.txt',\n         ...                              'test_doctest4.txt',\n         ...                              encoding='utf-8')\n         >>> suite.run(unittest.TestResult())\n         <unittest.result.TestResult run=3 errors=0 failures=2>\n\n       "

def test_trailing_space_in_test():
    "\n    Trailing spaces in expected output are significant:\n\n      >>> x, y = 'foo', ''\n      >>> print(x, y)\n      foo \n\n    "

class Wrapper():

    def __init__(self, func):
        self.func = func
        functools.update_wrapper(self, func)

    def __call__(self, *args, **kwargs):
        self.func(*args, **kwargs)

@Wrapper
def test_look_in_unwrapped():
    "\n    Docstrings in wrapped functions must be detected as well.\n\n    >>> 'one other test'\n    'one other test'\n    "

def test_unittest_reportflags():
    "Default unittest reporting flags can be set to control reporting\n\n    Here, we'll set the REPORT_ONLY_FIRST_FAILURE option so we see\n    only the first failure of each test.  First, we'll look at the\n    output without the flag.  The file test_doctest.txt file has two\n    tests. They both fail if blank lines are disabled:\n\n      >>> suite = doctest.DocFileSuite('test_doctest.txt',\n      ...                          optionflags=doctest.DONT_ACCEPT_BLANKLINE)\n      >>> import unittest\n      >>> result = suite.run(unittest.TestResult())\n      >>> print(result.failures[0][1]) # doctest: +ELLIPSIS\n      Traceback ...\n      Failed example:\n          favorite_color\n      ...\n      Failed example:\n          if 1:\n      ...\n\n    Note that we see both failures displayed.\n\n      >>> old = doctest.set_unittest_reportflags(\n      ...    doctest.REPORT_ONLY_FIRST_FAILURE)\n\n    Now, when we run the test:\n\n      >>> result = suite.run(unittest.TestResult())\n      >>> print(result.failures[0][1]) # doctest: +ELLIPSIS\n      Traceback ...\n      Failed example:\n          favorite_color\n      Exception raised:\n          ...\n          NameError: name 'favorite_color' is not defined\n      <BLANKLINE>\n      <BLANKLINE>\n\n    We get only the first failure.\n\n    If we give any reporting options when we set up the tests,\n    however:\n\n      >>> suite = doctest.DocFileSuite('test_doctest.txt',\n      ...     optionflags=doctest.DONT_ACCEPT_BLANKLINE | doctest.REPORT_NDIFF)\n\n    Then the default eporting options are ignored:\n\n      >>> result = suite.run(unittest.TestResult())\n\n    *NOTE*: These doctest are intentionally not placed in raw string to depict\n    the trailing whitespace using ` ` in the diff below.\n\n      >>> print(result.failures[0][1]) # doctest: +ELLIPSIS\n      Traceback ...\n      Failed example:\n          favorite_color\n      ...\n      Failed example:\n          if 1:\n             print('a')\n             print()\n             print('b')\n      Differences (ndiff with -expected +actual):\n            a\n          - <BLANKLINE>\n          + \n            b\n      <BLANKLINE>\n      <BLANKLINE>\n\n\n    Test runners can restore the formatting flags after they run:\n\n      >>> ignored = doctest.set_unittest_reportflags(old)\n\n    "

def test_testfile():
    '\nTests for the `testfile()` function.  This function runs all the\ndoctest examples in a given file.  In its simple invocation, it is\ncalled with the name of a file, which is taken to be relative to the\ncalling module.  The return value is (#failures, #tests).\n\nWe don\'t want `-v` in sys.argv for these tests.\n\n    >>> save_argv = sys.argv\n    >>> if \'-v\' in sys.argv:\n    ...     sys.argv = [arg for arg in save_argv if arg != \'-v\']\n\n\n    >>> doctest.testfile(\'test_doctest.txt\') # doctest: +ELLIPSIS\n    **********************************************************************\n    File "...", line 6, in test_doctest.txt\n    Failed example:\n        favorite_color\n    Exception raised:\n        ...\n        NameError: name \'favorite_color\' is not defined\n    **********************************************************************\n    1 items had failures:\n       1 of   2 in test_doctest.txt\n    ***Test Failed*** 1 failures.\n    TestResults(failed=1, attempted=2)\n    >>> doctest.master = None  # Reset master.\n\n(Note: we\'ll be clearing doctest.master after each call to\n`doctest.testfile`, to suppress warnings about multiple tests with the\nsame name.)\n\nGlobals may be specified with the `globs` and `extraglobs` parameters:\n\n    >>> globs = {\'favorite_color\': \'blue\'}\n    >>> doctest.testfile(\'test_doctest.txt\', globs=globs)\n    TestResults(failed=0, attempted=2)\n    >>> doctest.master = None  # Reset master.\n\n    >>> extraglobs = {\'favorite_color\': \'red\'}\n    >>> doctest.testfile(\'test_doctest.txt\', globs=globs,\n    ...                  extraglobs=extraglobs) # doctest: +ELLIPSIS\n    **********************************************************************\n    File "...", line 6, in test_doctest.txt\n    Failed example:\n        favorite_color\n    Expected:\n        \'blue\'\n    Got:\n        \'red\'\n    **********************************************************************\n    1 items had failures:\n       1 of   2 in test_doctest.txt\n    ***Test Failed*** 1 failures.\n    TestResults(failed=1, attempted=2)\n    >>> doctest.master = None  # Reset master.\n\nThe file may be made relative to a given module or package, using the\noptional `module_relative` parameter:\n\n    >>> doctest.testfile(\'test_doctest.txt\', globs=globs,\n    ...                  module_relative=\'test\')\n    TestResults(failed=0, attempted=2)\n    >>> doctest.master = None  # Reset master.\n\nVerbosity can be increased with the optional `verbose` parameter:\n\n    >>> doctest.testfile(\'test_doctest.txt\', globs=globs, verbose=True)\n    Trying:\n        favorite_color\n    Expecting:\n        \'blue\'\n    ok\n    Trying:\n        if 1:\n           print(\'a\')\n           print()\n           print(\'b\')\n    Expecting:\n        a\n        <BLANKLINE>\n        b\n    ok\n    1 items passed all tests:\n       2 tests in test_doctest.txt\n    2 tests in 1 items.\n    2 passed and 0 failed.\n    Test passed.\n    TestResults(failed=0, attempted=2)\n    >>> doctest.master = None  # Reset master.\n\nThe name of the test may be specified with the optional `name`\nparameter:\n\n    >>> doctest.testfile(\'test_doctest.txt\', name=\'newname\')\n    ... # doctest: +ELLIPSIS\n    **********************************************************************\n    File "...", line 6, in newname\n    ...\n    TestResults(failed=1, attempted=2)\n    >>> doctest.master = None  # Reset master.\n\nThe summary report may be suppressed with the optional `report`\nparameter:\n\n    >>> doctest.testfile(\'test_doctest.txt\', report=False)\n    ... # doctest: +ELLIPSIS\n    **********************************************************************\n    File "...", line 6, in test_doctest.txt\n    Failed example:\n        favorite_color\n    Exception raised:\n        ...\n        NameError: name \'favorite_color\' is not defined\n    TestResults(failed=1, attempted=2)\n    >>> doctest.master = None  # Reset master.\n\nThe optional keyword argument `raise_on_error` can be used to raise an\nexception on the first error (which may be useful for postmortem\ndebugging):\n\n    >>> doctest.testfile(\'test_doctest.txt\', raise_on_error=True)\n    ... # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n    doctest.UnexpectedException: ...\n    >>> doctest.master = None  # Reset master.\n\nIf the tests contain non-ASCII characters, the tests might fail, since\nit\'s unknown which encoding is used. The encoding can be specified\nusing the optional keyword argument `encoding`:\n\n    >>> doctest.testfile(\'test_doctest4.txt\', encoding=\'latin-1\') # doctest: +ELLIPSIS\n    **********************************************************************\n    File "...", line 7, in test_doctest4.txt\n    Failed example:\n        \'...\'\n    Expected:\n        \'f\\xf6\\xf6\'\n    Got:\n        \'f\\xc3\\xb6\\xc3\\xb6\'\n    **********************************************************************\n    ...\n    **********************************************************************\n    1 items had failures:\n       2 of   2 in test_doctest4.txt\n    ***Test Failed*** 2 failures.\n    TestResults(failed=2, attempted=2)\n    >>> doctest.master = None  # Reset master.\n\n    >>> doctest.testfile(\'test_doctest4.txt\', encoding=\'utf-8\')\n    TestResults(failed=0, attempted=2)\n    >>> doctest.master = None  # Reset master.\n\nTest the verbose output:\n\n    >>> doctest.testfile(\'test_doctest4.txt\', encoding=\'utf-8\', verbose=True)\n    Trying:\n        \'föö\'\n    Expecting:\n        \'f\\xf6\\xf6\'\n    ok\n    Trying:\n        \'bąr\'\n    Expecting:\n        \'b\\u0105r\'\n    ok\n    1 items passed all tests:\n       2 tests in test_doctest4.txt\n    2 tests in 1 items.\n    2 passed and 0 failed.\n    Test passed.\n    TestResults(failed=0, attempted=2)\n    >>> doctest.master = None  # Reset master.\n    >>> sys.argv = save_argv\n'

class TestImporter(importlib.abc.MetaPathFinder, importlib.abc.ResourceLoader):

    def find_spec(self, fullname, path, target=None):
        return importlib.util.spec_from_file_location(fullname, path, loader=self)

    def get_data(self, path):
        with open(path, mode='rb') as f:
            return f.read()

class TestHook():

    def __init__(self, pathdir):
        self.sys_path = sys.path[:]
        self.meta_path = sys.meta_path[:]
        self.path_hooks = sys.path_hooks[:]
        sys.path.append(pathdir)
        sys.path_importer_cache.clear()
        self.modules_before = sys.modules.copy()
        self.importer = TestImporter()
        sys.meta_path.append(self.importer)

    def remove(self):
        sys.path[:] = self.sys_path
        sys.meta_path[:] = self.meta_path
        sys.path_hooks[:] = self.path_hooks
        sys.path_importer_cache.clear()
        sys.modules.clear()
        sys.modules.update(self.modules_before)

@contextlib.contextmanager
def test_hook(pathdir):
    hook = TestHook(pathdir)
    try:
        (yield hook)
    finally:
        hook.remove()

def test_lineendings():
    '\n*nix systems use \\n line endings, while Windows systems use \\r\\n, and\nold Mac systems used \\r, which Python still recognizes as a line ending.  Python\nhandles this using universal newline mode for reading files.  Let\'s make\nsure doctest does so (issue 8473) by creating temporary test files using each\nof the three line disciplines.  At least one will not match either the universal\nnewline \\n or os.linesep for the platform the test is run on.\n\nWindows line endings first:\n\n    >>> import tempfile, os\n    >>> fn = tempfile.mktemp()\n    >>> with open(fn, \'wb\') as f:\n    ...    f.write(b\'Test:\\r\\n\\r\\n  >>> x = 1 + 1\\r\\n\\r\\nDone.\\r\\n\')\n    35\n    >>> doctest.testfile(fn, module_relative=False, verbose=False)\n    TestResults(failed=0, attempted=1)\n    >>> os.remove(fn)\n\nAnd now *nix line endings:\n\n    >>> fn = tempfile.mktemp()\n    >>> with open(fn, \'wb\') as f:\n    ...     f.write(b\'Test:\\n\\n  >>> x = 1 + 1\\n\\nDone.\\n\')\n    30\n    >>> doctest.testfile(fn, module_relative=False, verbose=False)\n    TestResults(failed=0, attempted=1)\n    >>> os.remove(fn)\n\nAnd finally old Mac line endings:\n\n    >>> fn = tempfile.mktemp()\n    >>> with open(fn, \'wb\') as f:\n    ...     f.write(b\'Test:\\r\\r  >>> x = 1 + 1\\r\\rDone.\\r\')\n    30\n    >>> doctest.testfile(fn, module_relative=False, verbose=False)\n    TestResults(failed=0, attempted=1)\n    >>> os.remove(fn)\n\nNow we test with a package loader that has a get_data method, since that\nbypasses the standard universal newline handling so doctest has to do the\nnewline conversion itself; let\'s make sure it does so correctly (issue 1812).\nWe\'ll write a file inside the package that has all three kinds of line endings\nin it, and use a package hook to install a custom loader; on any platform,\nat least one of the line endings will raise a ValueError for inconsistent\nwhitespace if doctest does not correctly do the newline conversion.\n\n    >>> dn = tempfile.mkdtemp()\n    >>> pkg = os.path.join(dn, "doctest_testpkg")\n    >>> os.mkdir(pkg)\n    >>> os_helper.create_empty_file(os.path.join(pkg, "__init__.py"))\n    >>> fn = os.path.join(pkg, "doctest_testfile.txt")\n    >>> with open(fn, \'wb\') as f:\n    ...     f.write(\n    ...         b\'Test:\\r\\n\\r\\n\'\n    ...         b\'  >>> x = 1 + 1\\r\\n\\r\\n\'\n    ...         b\'Done.\\r\\n\'\n    ...         b\'Test:\\n\\n\'\n    ...         b\'  >>> x = 1 + 1\\n\\n\'\n    ...         b\'Done.\\n\'\n    ...         b\'Test:\\r\\r\'\n    ...         b\'  >>> x = 1 + 1\\r\\r\'\n    ...         b\'Done.\\r\'\n    ...     )\n    95\n    >>> with test_hook(dn):\n    ...     doctest.testfile("doctest_testfile.txt", package="doctest_testpkg", verbose=False)\n    TestResults(failed=0, attempted=3)\n    >>> shutil.rmtree(dn)\n\n'

def test_testmod():
    '\nTests for the testmod function.  More might be useful, but for now we\'re just\ntesting the case raised by Issue 6195, where trying to doctest a C module would\nfail with a UnicodeDecodeError because doctest tried to read the "source" lines\nout of the binary module.\n\n    >>> import unicodedata\n    >>> doctest.testmod(unicodedata, verbose=False)\n    TestResults(failed=0, attempted=0)\n'
try:
    os.fsencode('foo-bär@baz.py')
except UnicodeEncodeError:
    pass
else:

    def test_unicode():
        '\nCheck doctest with a non-ascii filename:\n\n    >>> doc = \'\'\'\n    ... >>> raise Exception(\'clé\')\n    ... \'\'\'\n    ...\n    >>> parser = doctest.DocTestParser()\n    >>> test = parser.get_doctest(doc, {}, "foo-bär@baz", "foo-bär@baz.py", 0)\n    >>> test\n    <DocTest foo-bär@baz from foo-bär@baz.py:0 (1 example)>\n    >>> runner = doctest.DocTestRunner(verbose=False)\n    >>> runner.run(test) # doctest: +ELLIPSIS\n    **********************************************************************\n    File "foo-bär@baz.py", line 2, in foo-bär@baz\n    Failed example:\n        raise Exception(\'clé\')\n    Exception raised:\n        Traceback (most recent call last):\n          File ...\n            exec(compile(example.source, filename, "single",\n          File "<doctest foo-bär@baz[0]>", line 1, in <module>\n            raise Exception(\'clé\')\n        Exception: clé\n    TestResults(failed=1, attempted=1)\n    '

def test_CLI():
    '\nThe doctest module can be used to run doctests against an arbitrary file.\nThese tests test this CLI functionality.\n\nWe\'ll use the support module\'s script_helpers for this, and write a test files\nto a temp dir to run the command against.  Due to a current limitation in\nscript_helpers, though, we need a little utility function to turn the returned\noutput into something we can doctest against:\n\n    >>> def normalize(s):\n    ...     return \'\\n\'.join(s.decode().splitlines())\n\nWith those preliminaries out of the way, we\'ll start with a file with two\nsimple tests and no errors.  We\'ll run both the unadorned doctest command, and\nthe verbose version, and then check the output:\n\n    >>> from test.support import script_helper\n    >>> from test.support.os_helper import temp_dir\n    >>> with temp_dir() as tmpdir:\n    ...     fn = os.path.join(tmpdir, \'myfile.doc\')\n    ...     with open(fn, \'w\') as f:\n    ...         _ = f.write(\'This is a very simple test file.\\n\')\n    ...         _ = f.write(\'   >>> 1 + 1\\n\')\n    ...         _ = f.write(\'   2\\n\')\n    ...         _ = f.write(\'   >>> "a"\\n\')\n    ...         _ = f.write("   \'a\'\\n")\n    ...         _ = f.write(\'\\n\')\n    ...         _ = f.write(\'And that is it.\\n\')\n    ...     rc1, out1, err1 = script_helper.assert_python_ok(\n    ...             \'-m\', \'doctest\', fn)\n    ...     rc2, out2, err2 = script_helper.assert_python_ok(\n    ...             \'-m\', \'doctest\', \'-v\', fn)\n\nWith no arguments and passing tests, we should get no output:\n\n    >>> rc1, out1, err1\n    (0, b\'\', b\'\')\n\nWith the verbose flag, we should see the test output, but no error output:\n\n    >>> rc2, err2\n    (0, b\'\')\n    >>> print(normalize(out2))\n    Trying:\n        1 + 1\n    Expecting:\n        2\n    ok\n    Trying:\n        "a"\n    Expecting:\n        \'a\'\n    ok\n    1 items passed all tests:\n       2 tests in myfile.doc\n    2 tests in 1 items.\n    2 passed and 0 failed.\n    Test passed.\n\nNow we\'ll write a couple files, one with three tests, the other a python module\nwith two tests, both of the files having "errors" in the tests that can be made\nnon-errors by applying the appropriate doctest options to the run (ELLIPSIS in\nthe first file, NORMALIZE_WHITESPACE in the second).  This combination will\nallow thoroughly testing the -f and -o flags, as well as the doctest command\'s\nability to process more than one file on the command line and, since the second\nfile ends in \'.py\', its handling of python module files (as opposed to straight\ntext files).\n\n    >>> from test.support import script_helper\n    >>> from test.support.os_helper import temp_dir\n    >>> with temp_dir() as tmpdir:\n    ...     fn = os.path.join(tmpdir, \'myfile.doc\')\n    ...     with open(fn, \'w\') as f:\n    ...         _ = f.write(\'This is another simple test file.\\n\')\n    ...         _ = f.write(\'   >>> 1 + 1\\n\')\n    ...         _ = f.write(\'   2\\n\')\n    ...         _ = f.write(\'   >>> "abcdef"\\n\')\n    ...         _ = f.write("   \'a...f\'\\n")\n    ...         _ = f.write(\'   >>> "ajkml"\\n\')\n    ...         _ = f.write("   \'a...l\'\\n")\n    ...         _ = f.write(\'\\n\')\n    ...         _ = f.write(\'And that is it.\\n\')\n    ...     fn2 = os.path.join(tmpdir, \'myfile2.py\')\n    ...     with open(fn2, \'w\') as f:\n    ...         _ = f.write(\'def test_func():\\n\')\n    ...         _ = f.write(\'   \\"\\"\\"\\n\')\n    ...         _ = f.write(\'   This is simple python test function.\\n\')\n    ...         _ = f.write(\'       >>> 1 + 1\\n\')\n    ...         _ = f.write(\'       2\\n\')\n    ...         _ = f.write(\'       >>> "abc   def"\\n\')\n    ...         _ = f.write("       \'abc def\'\\n")\n    ...         _ = f.write("\\n")\n    ...         _ = f.write(\'   \\"\\"\\"\\n\')\n    ...     rc1, out1, err1 = script_helper.assert_python_failure(\n    ...             \'-m\', \'doctest\', fn, fn2)\n    ...     rc2, out2, err2 = script_helper.assert_python_ok(\n    ...             \'-m\', \'doctest\', \'-o\', \'ELLIPSIS\', fn)\n    ...     rc3, out3, err3 = script_helper.assert_python_ok(\n    ...             \'-m\', \'doctest\', \'-o\', \'ELLIPSIS\',\n    ...             \'-o\', \'NORMALIZE_WHITESPACE\', fn, fn2)\n    ...     rc4, out4, err4 = script_helper.assert_python_failure(\n    ...             \'-m\', \'doctest\', \'-f\', fn, fn2)\n    ...     rc5, out5, err5 = script_helper.assert_python_ok(\n    ...             \'-m\', \'doctest\', \'-v\', \'-o\', \'ELLIPSIS\',\n    ...             \'-o\', \'NORMALIZE_WHITESPACE\', fn, fn2)\n\nOur first test run will show the errors from the first file (doctest stops if a\nfile has errors).  Note that doctest test-run error output appears on stdout,\nnot stderr:\n\n    >>> rc1, err1\n    (1, b\'\')\n    >>> print(normalize(out1))                # doctest: +ELLIPSIS\n    **********************************************************************\n    File "...myfile.doc", line 4, in myfile.doc\n    Failed example:\n        "abcdef"\n    Expected:\n        \'a...f\'\n    Got:\n        \'abcdef\'\n    **********************************************************************\n    File "...myfile.doc", line 6, in myfile.doc\n    Failed example:\n        "ajkml"\n    Expected:\n        \'a...l\'\n    Got:\n        \'ajkml\'\n    **********************************************************************\n    1 items had failures:\n       2 of   3 in myfile.doc\n    ***Test Failed*** 2 failures.\n\nWith -o ELLIPSIS specified, the second run, against just the first file, should\nproduce no errors, and with -o NORMALIZE_WHITESPACE also specified, neither\nshould the third, which ran against both files:\n\n    >>> rc2, out2, err2\n    (0, b\'\', b\'\')\n    >>> rc3, out3, err3\n    (0, b\'\', b\'\')\n\nThe fourth run uses FAIL_FAST, so we should see only one error:\n\n    >>> rc4, err4\n    (1, b\'\')\n    >>> print(normalize(out4))                # doctest: +ELLIPSIS\n    **********************************************************************\n    File "...myfile.doc", line 4, in myfile.doc\n    Failed example:\n        "abcdef"\n    Expected:\n        \'a...f\'\n    Got:\n        \'abcdef\'\n    **********************************************************************\n    1 items had failures:\n       1 of   2 in myfile.doc\n    ***Test Failed*** 1 failures.\n\nThe fifth test uses verbose with the two options, so we should get verbose\nsuccess output for the tests in both files:\n\n    >>> rc5, err5\n    (0, b\'\')\n    >>> print(normalize(out5))\n    Trying:\n        1 + 1\n    Expecting:\n        2\n    ok\n    Trying:\n        "abcdef"\n    Expecting:\n        \'a...f\'\n    ok\n    Trying:\n        "ajkml"\n    Expecting:\n        \'a...l\'\n    ok\n    1 items passed all tests:\n       3 tests in myfile.doc\n    3 tests in 1 items.\n    3 passed and 0 failed.\n    Test passed.\n    Trying:\n        1 + 1\n    Expecting:\n        2\n    ok\n    Trying:\n        "abc   def"\n    Expecting:\n        \'abc def\'\n    ok\n    1 items had no tests:\n        myfile2\n    1 items passed all tests:\n       2 tests in myfile2.test_func\n    2 tests in 2 items.\n    2 passed and 0 failed.\n    Test passed.\n\nWe should also check some typical error cases.\n\nInvalid file name:\n\n    >>> rc, out, err = script_helper.assert_python_failure(\n    ...         \'-m\', \'doctest\', \'nosuchfile\')\n    >>> rc, out\n    (1, b\'\')\n    >>> print(normalize(err))                    # doctest: +ELLIPSIS\n    Traceback (most recent call last):\n      ...\n    FileNotFoundError: [Errno ...] No such file or directory: \'nosuchfile\'\n\nInvalid doctest option:\n\n    >>> rc, out, err = script_helper.assert_python_failure(\n    ...         \'-m\', \'doctest\', \'-o\', \'nosuchoption\')\n    >>> rc, out\n    (2, b\'\')\n    >>> print(normalize(err))                    # doctest: +ELLIPSIS\n    usage...invalid...nosuchoption...\n\n'

def test_no_trailing_whitespace_stripping():
    "\n    The fancy reports had a bug for a long time where any trailing whitespace on\n    the reported diff lines was stripped, making it impossible to see the\n    differences in line reported as different that differed only in the amount of\n    trailing whitespace.  The whitespace still isn't particularly visible unless\n    you use NDIFF, but at least it is now there to be found.\n\n    *NOTE*: This snippet was intentionally put inside a raw string to get rid of\n    leading whitespace error in executing the example below\n\n    >>> def f(x):\n    ...     r'''\n    ...     >>> print('\\n'.join(['a    ', 'b']))\n    ...     a\n    ...     b\n    ...     '''\n    "
    "\n    *NOTE*: These doctest are not placed in raw string to depict the trailing whitespace\n    using ` `\n\n    >>> test = doctest.DocTestFinder().find(f)[0]\n    >>> flags = doctest.REPORT_NDIFF\n    >>> doctest.DocTestRunner(verbose=False, optionflags=flags).run(test)\n    ... # doctest: +ELLIPSIS\n    **********************************************************************\n    File ..., line 3, in f\n    Failed example:\n        print('\n'.join(['a    ', 'b']))\n    Differences (ndiff with -expected +actual):\n        - a\n        + a\n          b\n    TestResults(failed=1, attempted=1)\n\n    *NOTE*: ` ` is for checking the trailing whitespace on the +a line above.\n    We cannot use actual spaces there, as a commit hook prevents from committing\n    patches that contain trailing whitespace. More info on Issue 24746.\n    "

def test_main():
    ret = support.run_doctest(doctest, verbosity=True)
    from test import test_doctest
    support.run_doctest(test_doctest, verbosity=True)
    support.run_unittest(__name__)

def test_coverage(coverdir):
    trace = import_helper.import_module('trace')
    tracer = trace.Trace(ignoredirs=[sys.base_prefix, sys.base_exec_prefix], trace=0, count=1)
    tracer.run('test_main()')
    r = tracer.results()
    print('Writing coverage results...')
    r.write_results(show_missing=True, summary=True, coverdir=coverdir)
if (__name__ == '__main__'):
    if ('-c' in sys.argv):
        test_coverage('/tmp/doctest.cover')
    else:
        test_main()
