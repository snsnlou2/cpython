
'Doctest for method/function calls.\n\nWe\'re going the use these types for extra testing\n\n    >>> from collections import UserList\n    >>> from collections import UserDict\n\nWe\'re defining four helper functions\n\n    >>> def e(a,b):\n    ...     print(a, b)\n\n    >>> def f(*a, **k):\n    ...     print(a, support.sortdict(k))\n\n    >>> def g(x, *y, **z):\n    ...     print(x, y, support.sortdict(z))\n\n    >>> def h(j=1, a=2, h=3):\n    ...     print(j, a, h)\n\nArgument list examples\n\n    >>> f()\n    () {}\n    >>> f(1)\n    (1,) {}\n    >>> f(1, 2)\n    (1, 2) {}\n    >>> f(1, 2, 3)\n    (1, 2, 3) {}\n    >>> f(1, 2, 3, *(4, 5))\n    (1, 2, 3, 4, 5) {}\n    >>> f(1, 2, 3, *[4, 5])\n    (1, 2, 3, 4, 5) {}\n    >>> f(*[1, 2, 3], 4, 5)\n    (1, 2, 3, 4, 5) {}\n    >>> f(1, 2, 3, *UserList([4, 5]))\n    (1, 2, 3, 4, 5) {}\n    >>> f(1, 2, 3, *[4, 5], *[6, 7])\n    (1, 2, 3, 4, 5, 6, 7) {}\n    >>> f(1, *[2, 3], 4, *[5, 6], 7)\n    (1, 2, 3, 4, 5, 6, 7) {}\n    >>> f(*UserList([1, 2]), *UserList([3, 4]), 5, *UserList([6, 7]))\n    (1, 2, 3, 4, 5, 6, 7) {}\n\nHere we add keyword arguments\n\n    >>> f(1, 2, 3, **{\'a\':4, \'b\':5})\n    (1, 2, 3) {\'a\': 4, \'b\': 5}\n    >>> f(1, 2, **{\'a\': -1, \'b\': 5}, **{\'a\': 4, \'c\': 6})\n    Traceback (most recent call last):\n        ...\n    TypeError: test.test_extcall.f() got multiple values for keyword argument \'a\'\n    >>> f(1, 2, **{\'a\': -1, \'b\': 5}, a=4, c=6)\n    Traceback (most recent call last):\n        ...\n    TypeError: test.test_extcall.f() got multiple values for keyword argument \'a\'\n    >>> f(1, 2, a=3, **{\'a\': 4}, **{\'a\': 5})\n    Traceback (most recent call last):\n        ...\n    TypeError: test.test_extcall.f() got multiple values for keyword argument \'a\'\n    >>> f(1, 2, 3, *[4, 5], **{\'a\':6, \'b\':7})\n    (1, 2, 3, 4, 5) {\'a\': 6, \'b\': 7}\n    >>> f(1, 2, 3, x=4, y=5, *(6, 7), **{\'a\':8, \'b\': 9})\n    (1, 2, 3, 6, 7) {\'a\': 8, \'b\': 9, \'x\': 4, \'y\': 5}\n    >>> f(1, 2, 3, *[4, 5], **{\'c\': 8}, **{\'a\':6, \'b\':7})\n    (1, 2, 3, 4, 5) {\'a\': 6, \'b\': 7, \'c\': 8}\n    >>> f(1, 2, 3, *(4, 5), x=6, y=7, **{\'a\':8, \'b\': 9})\n    (1, 2, 3, 4, 5) {\'a\': 8, \'b\': 9, \'x\': 6, \'y\': 7}\n\n    >>> f(1, 2, 3, **UserDict(a=4, b=5))\n    (1, 2, 3) {\'a\': 4, \'b\': 5}\n    >>> f(1, 2, 3, *(4, 5), **UserDict(a=6, b=7))\n    (1, 2, 3, 4, 5) {\'a\': 6, \'b\': 7}\n    >>> f(1, 2, 3, x=4, y=5, *(6, 7), **UserDict(a=8, b=9))\n    (1, 2, 3, 6, 7) {\'a\': 8, \'b\': 9, \'x\': 4, \'y\': 5}\n    >>> f(1, 2, 3, *(4, 5), x=6, y=7, **UserDict(a=8, b=9))\n    (1, 2, 3, 4, 5) {\'a\': 8, \'b\': 9, \'x\': 6, \'y\': 7}\n\nMix keyword arguments and dict unpacking\n\n    >>> d1 = {\'a\':1}\n\n    >>> d2 = {\'c\':3}\n\n    >>> f(b=2, **d1, **d2)\n    () {\'a\': 1, \'b\': 2, \'c\': 3}\n\n    >>> f(**d1, b=2, **d2)\n    () {\'a\': 1, \'b\': 2, \'c\': 3}\n\n    >>> f(**d1, **d2, b=2)\n    () {\'a\': 1, \'b\': 2, \'c\': 3}\n\n    >>> f(**d1, b=2, **d2, d=4)\n    () {\'a\': 1, \'b\': 2, \'c\': 3, \'d\': 4}\n\nExamples with invalid arguments (TypeErrors). We\'re also testing the function\nnames in the exception messages.\n\nVerify clearing of SF bug #733667\n\n    >>> e(c=4)\n    Traceback (most recent call last):\n      ...\n    TypeError: e() got an unexpected keyword argument \'c\'\n\n    >>> g()\n    Traceback (most recent call last):\n      ...\n    TypeError: g() missing 1 required positional argument: \'x\'\n\n    >>> g(*())\n    Traceback (most recent call last):\n      ...\n    TypeError: g() missing 1 required positional argument: \'x\'\n\n    >>> g(*(), **{})\n    Traceback (most recent call last):\n      ...\n    TypeError: g() missing 1 required positional argument: \'x\'\n\n    >>> g(1)\n    1 () {}\n    >>> g(1, 2)\n    1 (2,) {}\n    >>> g(1, 2, 3)\n    1 (2, 3) {}\n    >>> g(1, 2, 3, *(4, 5))\n    1 (2, 3, 4, 5) {}\n\n    >>> class Nothing: pass\n    ...\n    >>> g(*Nothing())\n    Traceback (most recent call last):\n      ...\n    TypeError: test.test_extcall.g() argument after * must be an iterable, not Nothing\n\n    >>> class Nothing:\n    ...     def __len__(self): return 5\n    ...\n\n    >>> g(*Nothing())\n    Traceback (most recent call last):\n      ...\n    TypeError: test.test_extcall.g() argument after * must be an iterable, not Nothing\n\n    >>> class Nothing():\n    ...     def __len__(self): return 5\n    ...     def __getitem__(self, i):\n    ...         if i<3: return i\n    ...         else: raise IndexError(i)\n    ...\n\n    >>> g(*Nothing())\n    0 (1, 2) {}\n\n    >>> class Nothing:\n    ...     def __init__(self): self.c = 0\n    ...     def __iter__(self): return self\n    ...     def __next__(self):\n    ...         if self.c == 4:\n    ...             raise StopIteration\n    ...         c = self.c\n    ...         self.c += 1\n    ...         return c\n    ...\n\n    >>> g(*Nothing())\n    0 (1, 2, 3) {}\n\nCheck for issue #4806: Does a TypeError in a generator get propagated with the\nright error message? (Also check with other iterables.)\n\n    >>> def broken(): raise TypeError("myerror")\n    ...\n\n    >>> g(*(broken() for i in range(1)))\n    Traceback (most recent call last):\n      ...\n    TypeError: myerror\n    >>> g(*range(1), *(broken() for i in range(1)))\n    Traceback (most recent call last):\n      ...\n    TypeError: myerror\n\n    >>> class BrokenIterable1:\n    ...     def __iter__(self):\n    ...         raise TypeError(\'myerror\')\n    ...\n    >>> g(*BrokenIterable1())\n    Traceback (most recent call last):\n      ...\n    TypeError: myerror\n    >>> g(*range(1), *BrokenIterable1())\n    Traceback (most recent call last):\n      ...\n    TypeError: myerror\n\n    >>> class BrokenIterable2:\n    ...     def __iter__(self):\n    ...         yield 0\n    ...         raise TypeError(\'myerror\')\n    ...\n    >>> g(*BrokenIterable2())\n    Traceback (most recent call last):\n      ...\n    TypeError: myerror\n    >>> g(*range(1), *BrokenIterable2())\n    Traceback (most recent call last):\n      ...\n    TypeError: myerror\n\n    >>> class BrokenSequence:\n    ...     def __getitem__(self, idx):\n    ...         raise TypeError(\'myerror\')\n    ...\n    >>> g(*BrokenSequence())\n    Traceback (most recent call last):\n      ...\n    TypeError: myerror\n    >>> g(*range(1), *BrokenSequence())\n    Traceback (most recent call last):\n      ...\n    TypeError: myerror\n\nMake sure that the function doesn\'t stomp the dictionary\n\n    >>> d = {\'a\': 1, \'b\': 2, \'c\': 3}\n    >>> d2 = d.copy()\n    >>> g(1, d=4, **d)\n    1 () {\'a\': 1, \'b\': 2, \'c\': 3, \'d\': 4}\n    >>> d == d2\n    True\n\nWhat about willful misconduct?\n\n    >>> def saboteur(**kw):\n    ...     kw[\'x\'] = \'m\'\n    ...     return kw\n\n    >>> d = {}\n    >>> kw = saboteur(a=1, **d)\n    >>> d\n    {}\n\n\n    >>> g(1, 2, 3, **{\'x\': 4, \'y\': 5})\n    Traceback (most recent call last):\n      ...\n    TypeError: g() got multiple values for argument \'x\'\n\n    >>> f(**{1:2})\n    Traceback (most recent call last):\n      ...\n    TypeError: keywords must be strings\n\n    >>> h(**{\'e\': 2})\n    Traceback (most recent call last):\n      ...\n    TypeError: h() got an unexpected keyword argument \'e\'\n\n    >>> h(*h)\n    Traceback (most recent call last):\n      ...\n    TypeError: test.test_extcall.h() argument after * must be an iterable, not function\n\n    >>> h(1, *h)\n    Traceback (most recent call last):\n      ...\n    TypeError: Value after * must be an iterable, not function\n\n    >>> h(*[1], *h)\n    Traceback (most recent call last):\n      ...\n    TypeError: Value after * must be an iterable, not function\n\n    >>> dir(*h)\n    Traceback (most recent call last):\n      ...\n    TypeError: dir() argument after * must be an iterable, not function\n\n    >>> nothing = None\n    >>> nothing(*h)\n    Traceback (most recent call last):\n      ...\n    TypeError: None argument after * must be an iterable, not function\n\n    >>> h(**h)\n    Traceback (most recent call last):\n      ...\n    TypeError: test.test_extcall.h() argument after ** must be a mapping, not function\n\n    >>> h(**[])\n    Traceback (most recent call last):\n      ...\n    TypeError: test.test_extcall.h() argument after ** must be a mapping, not list\n\n    >>> h(a=1, **h)\n    Traceback (most recent call last):\n      ...\n    TypeError: test.test_extcall.h() argument after ** must be a mapping, not function\n\n    >>> h(a=1, **[])\n    Traceback (most recent call last):\n      ...\n    TypeError: test.test_extcall.h() argument after ** must be a mapping, not list\n\n    >>> h(**{\'a\': 1}, **h)\n    Traceback (most recent call last):\n      ...\n    TypeError: test.test_extcall.h() argument after ** must be a mapping, not function\n\n    >>> h(**{\'a\': 1}, **[])\n    Traceback (most recent call last):\n      ...\n    TypeError: test.test_extcall.h() argument after ** must be a mapping, not list\n\n    >>> dir(**h)\n    Traceback (most recent call last):\n      ...\n    TypeError: dir() argument after ** must be a mapping, not function\n\n    >>> nothing(**h)\n    Traceback (most recent call last):\n      ...\n    TypeError: None argument after ** must be a mapping, not function\n\n    >>> dir(b=1, **{\'b\': 1})\n    Traceback (most recent call last):\n      ...\n    TypeError: dir() got multiple values for keyword argument \'b\'\n\nTest a kwargs mapping with duplicated keys.\n\n    >>> from collections.abc import Mapping\n    >>> class MultiDict(Mapping):\n    ...     def __init__(self, items):\n    ...         self._items = items\n    ...\n    ...     def __iter__(self):\n    ...         return (k for k, v in self._items)\n    ...\n    ...     def __getitem__(self, key):\n    ...         for k, v in self._items:\n    ...             if k == key:\n    ...                 return v\n    ...         raise KeyError(key)\n    ...\n    ...     def __len__(self):\n    ...         return len(self._items)\n    ...\n    ...     def keys(self):\n    ...         return [k for k, v in self._items]\n    ...\n    ...     def values(self):\n    ...         return [v for k, v in self._items]\n    ...\n    ...     def items(self):\n    ...         return [(k, v) for k, v in self._items]\n    ...\n    >>> g(**MultiDict([(\'x\', 1), (\'y\', 2)]))\n    1 () {\'y\': 2}\n\n    >>> g(**MultiDict([(\'x\', 1), (\'x\', 2)]))\n    Traceback (most recent call last):\n      ...\n    TypeError: test.test_extcall.g() got multiple values for keyword argument \'x\'\n\n    >>> g(a=3, **MultiDict([(\'x\', 1), (\'x\', 2)]))\n    Traceback (most recent call last):\n      ...\n    TypeError: test.test_extcall.g() got multiple values for keyword argument \'x\'\n\n    >>> g(**MultiDict([(\'a\', 3)]), **MultiDict([(\'x\', 1), (\'x\', 2)]))\n    Traceback (most recent call last):\n      ...\n    TypeError: test.test_extcall.g() got multiple values for keyword argument \'x\'\n\nAnother helper function\n\n    >>> def f2(*a, **b):\n    ...     return a, b\n\n\n    >>> d = {}\n    >>> for i in range(512):\n    ...     key = \'k%d\' % i\n    ...     d[key] = i\n    >>> a, b = f2(1, *(2,3), **d)\n    >>> len(a), len(b), b == d\n    (3, 512, True)\n\n    >>> class Foo:\n    ...     def method(self, arg1, arg2):\n    ...         return arg1+arg2\n\n    >>> x = Foo()\n    >>> Foo.method(*(x, 1, 2))\n    3\n    >>> Foo.method(x, *(1, 2))\n    3\n    >>> Foo.method(*(1, 2, 3))\n    5\n    >>> Foo.method(1, *[2, 3])\n    5\n\nA PyCFunction that takes only positional parameters should allow an\nempty keyword dictionary to pass without a complaint, but raise a\nTypeError if te dictionary is not empty\n\n    >>> try:\n    ...     silence = id(1, *{})\n    ...     True\n    ... except:\n    ...     False\n    True\n\n    >>> id(1, **{\'foo\': 1})\n    Traceback (most recent call last):\n      ...\n    TypeError: id() takes no keyword arguments\n\nA corner case of keyword dictionary items being deleted during\nthe function call setup. See <http://bugs.python.org/issue2016>.\n\n    >>> class Name(str):\n    ...     def __eq__(self, other):\n    ...         try:\n    ...              del x[self]\n    ...         except KeyError:\n    ...              pass\n    ...         return str.__eq__(self, other)\n    ...     def __hash__(self):\n    ...         return str.__hash__(self)\n\n    >>> x = {Name("a"):1, Name("b"):2}\n    >>> def f(a, b):\n    ...     print(a,b)\n    >>> f(**x)\n    1 2\n\nToo many arguments:\n\n    >>> def f(): pass\n    >>> f(1)\n    Traceback (most recent call last):\n      ...\n    TypeError: f() takes 0 positional arguments but 1 was given\n    >>> def f(a): pass\n    >>> f(1, 2)\n    Traceback (most recent call last):\n      ...\n    TypeError: f() takes 1 positional argument but 2 were given\n    >>> def f(a, b=1): pass\n    >>> f(1, 2, 3)\n    Traceback (most recent call last):\n      ...\n    TypeError: f() takes from 1 to 2 positional arguments but 3 were given\n    >>> def f(*, kw): pass\n    >>> f(1, kw=3)\n    Traceback (most recent call last):\n      ...\n    TypeError: f() takes 0 positional arguments but 1 positional argument (and 1 keyword-only argument) were given\n    >>> def f(*, kw, b): pass\n    >>> f(1, 2, 3, b=3, kw=3)\n    Traceback (most recent call last):\n      ...\n    TypeError: f() takes 0 positional arguments but 3 positional arguments (and 2 keyword-only arguments) were given\n    >>> def f(a, b=2, *, kw): pass\n    >>> f(2, 3, 4, kw=4)\n    Traceback (most recent call last):\n      ...\n    TypeError: f() takes from 1 to 2 positional arguments but 3 positional arguments (and 1 keyword-only argument) were given\n\nToo few and missing arguments:\n\n    >>> def f(a): pass\n    >>> f()\n    Traceback (most recent call last):\n      ...\n    TypeError: f() missing 1 required positional argument: \'a\'\n    >>> def f(a, b): pass\n    >>> f()\n    Traceback (most recent call last):\n      ...\n    TypeError: f() missing 2 required positional arguments: \'a\' and \'b\'\n    >>> def f(a, b, c): pass\n    >>> f()\n    Traceback (most recent call last):\n      ...\n    TypeError: f() missing 3 required positional arguments: \'a\', \'b\', and \'c\'\n    >>> def f(a, b, c, d, e): pass\n    >>> f()\n    Traceback (most recent call last):\n      ...\n    TypeError: f() missing 5 required positional arguments: \'a\', \'b\', \'c\', \'d\', and \'e\'\n    >>> def f(a, b=4, c=5, d=5): pass\n    >>> f(c=12, b=9)\n    Traceback (most recent call last):\n      ...\n    TypeError: f() missing 1 required positional argument: \'a\'\n\nSame with keyword only args:\n\n    >>> def f(*, w): pass\n    >>> f()\n    Traceback (most recent call last):\n      ...\n    TypeError: f() missing 1 required keyword-only argument: \'w\'\n    >>> def f(*, a, b, c, d, e): pass\n    >>> f()\n    Traceback (most recent call last):\n      ...\n    TypeError: f() missing 5 required keyword-only arguments: \'a\', \'b\', \'c\', \'d\', and \'e\'\n\n'
import sys
from test import support

def test_main():
    support.run_doctest(sys.modules[__name__], True)
if (__name__ == '__main__'):
    test_main()
