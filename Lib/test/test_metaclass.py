
doctests = '\n\nBasic class construction.\n\n    >>> class C:\n    ...     def meth(self): print("Hello")\n    ...\n    >>> C.__class__ is type\n    True\n    >>> a = C()\n    >>> a.__class__ is C\n    True\n    >>> a.meth()\n    Hello\n    >>>\n\nUse *args notation for the bases.\n\n    >>> class A: pass\n    >>> class B: pass\n    >>> bases = (A, B)\n    >>> class C(*bases): pass\n    >>> C.__bases__ == bases\n    True\n    >>>\n\nUse a trivial metaclass.\n\n    >>> class M(type):\n    ...     pass\n    ...\n    >>> class C(metaclass=M):\n    ...    def meth(self): print("Hello")\n    ...\n    >>> C.__class__ is M\n    True\n    >>> a = C()\n    >>> a.__class__ is C\n    True\n    >>> a.meth()\n    Hello\n    >>>\n\nUse **kwds notation for the metaclass keyword.\n\n    >>> kwds = {\'metaclass\': M}\n    >>> class C(**kwds): pass\n    ...\n    >>> C.__class__ is M\n    True\n    >>> a = C()\n    >>> a.__class__ is C\n    True\n    >>>\n\nUse a metaclass with a __prepare__ static method.\n\n    >>> class M(type):\n    ...    @staticmethod\n    ...    def __prepare__(*args, **kwds):\n    ...        print("Prepare called:", args, kwds)\n    ...        return dict()\n    ...    def __new__(cls, name, bases, namespace, **kwds):\n    ...        print("New called:", kwds)\n    ...        return type.__new__(cls, name, bases, namespace)\n    ...    def __init__(cls, *args, **kwds):\n    ...        pass\n    ...\n    >>> class C(metaclass=M):\n    ...     def meth(self): print("Hello")\n    ...\n    Prepare called: (\'C\', ()) {}\n    New called: {}\n    >>>\n\nAlso pass another keyword.\n\n    >>> class C(object, metaclass=M, other="haha"):\n    ...     pass\n    ...\n    Prepare called: (\'C\', (<class \'object\'>,)) {\'other\': \'haha\'}\n    New called: {\'other\': \'haha\'}\n    >>> C.__class__ is M\n    True\n    >>> C.__bases__ == (object,)\n    True\n    >>> a = C()\n    >>> a.__class__ is C\n    True\n    >>>\n\nCheck that build_class doesn\'t mutate the kwds dict.\n\n    >>> kwds = {\'metaclass\': type}\n    >>> class C(**kwds): pass\n    ...\n    >>> kwds == {\'metaclass\': type}\n    True\n    >>>\n\nUse various combinations of explicit keywords and **kwds.\n\n    >>> bases = (object,)\n    >>> kwds = {\'metaclass\': M, \'other\': \'haha\'}\n    >>> class C(*bases, **kwds): pass\n    ...\n    Prepare called: (\'C\', (<class \'object\'>,)) {\'other\': \'haha\'}\n    New called: {\'other\': \'haha\'}\n    >>> C.__class__ is M\n    True\n    >>> C.__bases__ == (object,)\n    True\n    >>> class B: pass\n    >>> kwds = {\'other\': \'haha\'}\n    >>> class C(B, metaclass=M, *bases, **kwds): pass\n    ...\n    Prepare called: (\'C\', (<class \'test.test_metaclass.B\'>, <class \'object\'>)) {\'other\': \'haha\'}\n    New called: {\'other\': \'haha\'}\n    >>> C.__class__ is M\n    True\n    >>> C.__bases__ == (B, object)\n    True\n    >>>\n\nCheck for duplicate keywords.\n\n    >>> class C(metaclass=type, metaclass=type): pass\n    ...\n    Traceback (most recent call last):\n    [...]\n    SyntaxError: keyword argument repeated: metaclass\n    >>>\n\nAnother way.\n\n    >>> kwds = {\'metaclass\': type}\n    >>> class C(metaclass=type, **kwds): pass\n    ...\n    Traceback (most recent call last):\n    [...]\n    TypeError: __build_class__() got multiple values for keyword argument \'metaclass\'\n    >>>\n\nUse a __prepare__ method that returns an instrumented dict.\n\n    >>> class LoggingDict(dict):\n    ...     def __setitem__(self, key, value):\n    ...         print("d[%r] = %r" % (key, value))\n    ...         dict.__setitem__(self, key, value)\n    ...\n    >>> class Meta(type):\n    ...    @staticmethod\n    ...    def __prepare__(name, bases):\n    ...        return LoggingDict()\n    ...\n    >>> class C(metaclass=Meta):\n    ...     foo = 2+2\n    ...     foo = 42\n    ...     bar = 123\n    ...\n    d[\'__module__\'] = \'test.test_metaclass\'\n    d[\'__qualname__\'] = \'C\'\n    d[\'foo\'] = 4\n    d[\'foo\'] = 42\n    d[\'bar\'] = 123\n    >>>\n\nUse a metaclass that doesn\'t derive from type.\n\n    >>> def meta(name, bases, namespace, **kwds):\n    ...     print("meta:", name, bases)\n    ...     print("ns:", sorted(namespace.items()))\n    ...     print("kw:", sorted(kwds.items()))\n    ...     return namespace\n    ...\n    >>> class C(metaclass=meta):\n    ...     a = 42\n    ...     b = 24\n    ...\n    meta: C ()\n    ns: [(\'__module__\', \'test.test_metaclass\'), (\'__qualname__\', \'C\'), (\'a\', 42), (\'b\', 24)]\n    kw: []\n    >>> type(C) is dict\n    True\n    >>> print(sorted(C.items()))\n    [(\'__module__\', \'test.test_metaclass\'), (\'__qualname__\', \'C\'), (\'a\', 42), (\'b\', 24)]\n    >>>\n\nAnd again, with a __prepare__ attribute.\n\n    >>> def prepare(name, bases, **kwds):\n    ...     print("prepare:", name, bases, sorted(kwds.items()))\n    ...     return LoggingDict()\n    ...\n    >>> meta.__prepare__ = prepare\n    >>> class C(metaclass=meta, other="booh"):\n    ...    a = 1\n    ...    a = 2\n    ...    b = 3\n    ...\n    prepare: C () [(\'other\', \'booh\')]\n    d[\'__module__\'] = \'test.test_metaclass\'\n    d[\'__qualname__\'] = \'C\'\n    d[\'a\'] = 1\n    d[\'a\'] = 2\n    d[\'b\'] = 3\n    meta: C ()\n    ns: [(\'__module__\', \'test.test_metaclass\'), (\'__qualname__\', \'C\'), (\'a\', 2), (\'b\', 3)]\n    kw: [(\'other\', \'booh\')]\n    >>>\n\nThe default metaclass must define a __prepare__() method.\n\n    >>> type.__prepare__()\n    {}\n    >>>\n\nMake sure it works with subclassing.\n\n    >>> class M(type):\n    ...     @classmethod\n    ...     def __prepare__(cls, *args, **kwds):\n    ...         d = super().__prepare__(*args, **kwds)\n    ...         d["hello"] = 42\n    ...         return d\n    ...\n    >>> class C(metaclass=M):\n    ...     print(hello)\n    ...\n    42\n    >>> print(C.hello)\n    42\n    >>>\n\nTest failures in looking up the __prepare__ method work.\n    >>> class ObscureException(Exception):\n    ...     pass\n    >>> class FailDescr:\n    ...     def __get__(self, instance, owner):\n    ...        raise ObscureException\n    >>> class Meta(type):\n    ...     __prepare__ = FailDescr()\n    >>> class X(metaclass=Meta):\n    ...     pass\n    Traceback (most recent call last):\n    [...]\n    test.test_metaclass.ObscureException\n\n'
import sys
if (hasattr(sys, 'gettrace') and sys.gettrace()):
    __test__ = {}
else:
    __test__ = {'doctests': doctests}

def test_main(verbose=False):
    from test import support
    from test import test_metaclass
    support.run_doctest(test_metaclass, verbose)
if (__name__ == '__main__'):
    test_main(verbose=True)
